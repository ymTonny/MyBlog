<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>js数组去重多一种选择</title>
    <url>/2019/08/11/array/</url>
    <content><![CDATA[<p>数组去重，一般在面试的时候都会被问到，要求现场写去重代码，那么你知道有多少去重的方法呢？如果你能答出多种的话，面试官一定会对你刮目相看的。</p>
<p>数组去重的方法：</p>
<h2 id="一、利用ES6-Set去重"><a href="#一、利用ES6-Set去重" class="headerlink" title="一、利用ES6 Set去重"></a>一、利用ES6 Set去重</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr)&#123;</span><br><span class="line">  return Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br><span class="line">let arr = [1,1,2,2,3,3];</span><br><span class="line">console.log(uniq(arr));</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果不考虑兼容性的话，此方法代码最少。</p>
<h2 id="二、利用splice去重。"><a href="#二、利用splice去重。" class="headerlink" title="二、利用splice去重。"></a>二、利用splice去重。</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr)&#123;</span><br><span class="line">  if(!Array.isArray(arr))&#123;</span><br><span class="line">     console.log(&quot;no array&quot;);</span><br><span class="line">     return</span><br><span class="line">  &#125;</span><br><span class="line">  for(let i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    for(let j=i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">       if(arr[i]==arr[j])&#123;</span><br><span class="line">         arr.splice(j,1);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br><span class="line">let arr=[1,1,2,2,3,3];</span><br><span class="line">console.log(uniq(arr));</span><br></pre></td></tr></table></figure>
<p>双重for循环，外层循环元素，内层判断值，值相等就通过<code>splice</code>删除。</p>
<h2 id="三、利用indexOf去重"><a href="#三、利用indexOf去重" class="headerlink" title="三、利用indexOf去重"></a>三、利用indexOf去重</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr)&#123;</span><br><span class="line">  if(!Array.isArray(arr))&#123;</span><br><span class="line">     console.log(&quot;no array&quot;);</span><br><span class="line">     return</span><br><span class="line">  &#125;</span><br><span class="line">  let array=[];</span><br><span class="line">  for(let i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">     if(array.indexOf(arr[i])==-1)&#123;</span><br><span class="line">       array.push(arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return array;</span><br><span class="line">&#125;</span><br><span class="line">let arr=[1,1,2,2,3,3];</span><br><span class="line">console.log(uniq(arr))</span><br></pre></td></tr></table></figure>
<p>通过新建一个空数组，for循环判断空数组中是否存在当前元素，如果不存在就<code>push</code>进去，如果存在就跳过。</p>
<h2 id="四、利用sort"><a href="#四、利用sort" class="headerlink" title="四、利用sort()"></a>四、利用sort()</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr)&#123;</span><br><span class="line"> if(!Array.isArray(arr))&#123;</span><br><span class="line">   console.log(&quot;no array&quot;);</span><br><span class="line">   return</span><br><span class="line"> &#125;</span><br><span class="line"> arr = arr.sort();</span><br><span class="line"> let array = [];</span><br><span class="line"> for(let i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">   if(arr[i]!=arr[i+1])&#123;</span><br><span class="line">     array.push(arr[i]);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return array;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [1,2,3,6,4,2,1];</span><br><span class="line">console.log(uniq(arr))</span><br></pre></td></tr></table></figure>
<p>通过<code>sort()</code>排序过后，再用for循环遍历比较相邻元素。</p>
<h2 id="五、利用对象的属性不能相同去重"><a href="#五、利用对象的属性不能相同去重" class="headerlink" title="五、利用对象的属性不能相同去重"></a>五、利用对象的属性不能相同去重</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr)&#123;</span><br><span class="line">  if(!Array.isArray(arr))&#123;</span><br><span class="line">    console.log(&quot;no array&quot;);</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  let array=[],obj=&#123;&#125;;</span><br><span class="line">  for(let i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(!obj[arr[i]])&#123;</span><br><span class="line">      array.push(arr[i]);</span><br><span class="line">      obj[arr[i]]=1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      obj[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return array;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [1,2,3,4,2,3,1];</span><br><span class="line">console.log(uniq(arr))</span><br></pre></td></tr></table></figure>
<h2 id="六、利用includes"><a href="#六、利用includes" class="headerlink" title="六、利用includes"></a>六、利用includes</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr)&#123;</span><br><span class="line"> if(!Array.isArray(arr))&#123;</span><br><span class="line">   console.log(&quot;no array&quot;);</span><br><span class="line">   return;</span><br><span class="line"> &#125;</span><br><span class="line"> let array = [];</span><br><span class="line"> for(let i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">   if(!array.includes(arr[i]))&#123; //array中是否存在arr[i]元素</span><br><span class="line">     array.push(arr[i]);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return array;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [1,2,3,5,2,1];</span><br><span class="line">console.log(uniq(arr));</span><br></pre></td></tr></table></figure>
<h2 id="七、利用hasOwnProperty"><a href="#七、利用hasOwnProperty" class="headerlink" title="七、利用hasOwnProperty"></a>七、利用hasOwnProperty</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr)&#123;</span><br><span class="line"> let obj = &#123;&#125;;</span><br><span class="line"> return arr.filter((item,index,arr)=&gt;&#123;</span><br><span class="line">   return obj.hasOwnProperty(typeof item+item) ? false:(obj[typeof item+item]=true)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">let arr = [1,2,3,5,2,1];</span><br><span class="line">console.log(uniq(arr));</span><br></pre></td></tr></table></figure>
<h2 id="八、利用filter"><a href="#八、利用filter" class="headerlink" title="八、利用filter"></a>八、利用filter</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr)&#123;</span><br><span class="line"> return arr.filter((item,index,arr)=&gt;&#123;</span><br><span class="line">   //当前元素，在原数组中的第一个索引 === 当前索引值,否则返回当前元素</span><br><span class="line">   return arr.indexOf(item,0) === index;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">let arr = [1,2,3,5,2,1];</span><br><span class="line">console.log(uniq(arr));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>async-await</title>
    <url>/2019/08/02/async-await/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>   <code>Asyns-Await</code>,异步编程的最高境界，就是根本不用担心它异步。<code>async</code>函数就是隧道尽头的亮光，大部分人会认为它是异步操作的终极解决方案。<code>async-await</code>和<code>promise</code>的关系，两者不存在谁代替谁，因为<code>async-await</code>寄生于<code>Promise</code>.<code>Generator</code>的语法糖。<code>async</code>和<code>await</code>在干什么？<code>async</code>用于申明一个<code>function</code>函数是异步的，而<code>await</code>可以认为是<code>async await</code>的简写，等待一个异步函数执行完成。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function demo(params)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">//async 函数返回的是一个Promise对象</span><br><span class="line">demo();</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ul>
<li>async表示这是一个async函数，await只能用在这个函数里面。</li>
<li>await表示这里等待promise返回结果后，再继续执行。</li>
<li>await后面应该跟着一个promise对象（普通函数亦可，但await就无意义了）。</li>
<li>await不能单独使用，必须搭配aync函数来使用。</li>
<li>await等待的虽然是一个promise对象，但是不必写.then(…),直接可以得到返回值。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function demo(params)&#123;</span><br><span class="line">   let result = await Promise.resolve(123);</span><br><span class="line">   console.log(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="捕捉错误"><a href="#捕捉错误" class="headerlink" title="捕捉错误"></a>捕捉错误</h2><p>像<code>Promise</code>有<code>.then(...),.catch(...)</code>来捕捉正确与错误，而<code>async</code>这两个都不用写，那么我们就可以直接用标准的<code>try catch</code>语法捕捉错误。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sleep = function (time) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            // 模拟出错了，返回 ‘error’</span><br><span class="line">            reject(&apos;error&apos;);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let start = async function () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        console.log(&apos;start&apos;);</span><br><span class="line">        await sleep(3000); // 这里得到了一个返回错误</span><br><span class="line">        </span><br><span class="line">        // 所以以下代码不会被执行了</span><br><span class="line">        console.log(&apos;end&apos;);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        console.log(err); // 这里捕捉到错误 `error`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="循环多个await"><a href="#循环多个await" class="headerlink" title="循环多个await"></a>循环多个await</h2><p><code>await</code>看起来像是同步代码,所以写在for循环内，不必担心需要闭包才能解决。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">..省略以上代码</span><br><span class="line"></span><br><span class="line">let start = async function () &#123;</span><br><span class="line">    for (let i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">        console.log(`当前是第$&#123;i&#125;次等待..`);</span><br><span class="line">        await sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转clip-path</title>
    <url>/2019/07/23/clip-path/</url>
    <content><![CDATA[<h1 id="一-基本概念"><a href="#一-基本概念" class="headerlink" title="一.基本概念"></a>一.基本概念</h1><p>什么是<code>clip-path</code>呢？简而言之就是实现裁剪的<code>css</code>属性,我们可以通过该属性创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的部分隐藏。通过指定路径就可以创建出自己想要的形状，这样网页中的布局就可以是多种多样的了。</p>
<p>在<code>clip-path</code>出现之前，css还有个属性<code>clip</code>也支持裁剪，但是它只支持矩形裁剪,同时它只对<code>position:absolute</code>和<code>position:fixed</code>的元素生效。使用如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clip: rect(50px,50px,50px,50px) //标准写法</span><br><span class="line">clip: rect(50px 50px 50px 50px) //兼容浏览器写法</span><br></pre></td></tr></table></figure></p>
<p>目前所有主流浏览器都支持<code>clip</code>,但是因为其局限性,<code>clip</code>已经被<code>clip-path</code>代替。<code>clip-path</code>为我们带来了更多的可能，让我们制作出更多有趣的图案。<br><a id="more"></a></p>
<h1 id="二-用法实例"><a href="#二-用法实例" class="headerlink" title="二.用法实例"></a>二.用法实例</h1><h2 id="1-基本图形：inset"><a href="#1-基本图形：inset" class="headerlink" title="1.基本图形：inset"></a>1.基本图形：inset</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inset()//定义一个矩形,注意:此处矩形不是 rect 而是 inset.</span><br><span class="line">//语法</span><br><span class="line">inset()可以传入5个参数，分别对应top,right,bottom,left的裁剪位置,和round radius（可选项 圆角）。</span><br><span class="line"></span><br><span class="line">//示例</span><br><span class="line">clip-path:inset(15% 20% 15% 20%)</span><br></pre></td></tr></table></figure>
 <div style="width:200px;height:200px;margin:auto"><img src="https://s2.ax1x.com/2019/03/27/Aa7B0s.png" alt="avatart"></div>

<h2 id="2-基本图形：circle"><a href="#2-基本图形：circle" class="headerlink" title="2.基本图形：circle"></a>2.基本图形：circle</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">circle()//定义一个圆形</span><br><span class="line">//语法</span><br><span class="line">circle()//可以传入2个参数，用at分开,分别对应圆的半径,圆心位置。圆心默认为元素中心点。</span><br><span class="line">//示例</span><br><span class="line">clip-path:circle(50% at 50% 50%)</span><br></pre></td></tr></table></figure>
 <div style="width:200px;height:200px;margin:auto"><img src="https://ws2.sinaimg.cn/mw690/005SNrnIgy1g1hef0awp6j308r08gq6d.jpg" alt="avatart"></div>

<h2 id="3-基本图形：ellipse"><a href="#3-基本图形：ellipse" class="headerlink" title="3.基本图形：ellipse"></a>3.基本图形：ellipse</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ellipse()//定义一个椭圆</span><br><span class="line">//语法</span><br><span class="line">ellipse(x y at positon)//x为椭圆的x轴半径,y为椭圆的y轴半径,position为椭圆中心位置。</span><br><span class="line">//示例</span><br><span class="line">clip-path:ellipse(25% 40% at 50% 50%)</span><br></pre></td></tr></table></figure>
<p> <div style="width:200px;height:200px;margin:auto"><img src="https://ws2.sinaimg.cn/mw690/005SNrnIgy1g1hekwf3c2j308i089myl.jpg" alt="avatart"></div></p>
<h2 id="4-基本图形：polygon"><a href="#4-基本图形：polygon" class="headerlink" title="4.基本图形：polygon"></a>4.基本图形：polygon</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plygon()//定义一个多边形</span><br><span class="line">//语法</span><br><span class="line">polygon(fill-rule,[x y])//fill-rule(可选)表示填充规则用来确定该多边形内部,值有nonzero 和evenodd，默认为evenodd。后面的每一对表示连接点的坐标。</span><br><span class="line">//示例</span><br><span class="line">clip-path: polygon(50% 0%, 0 100%, 100% 100%);</span><br><span class="line">clip-path: polygon(20% 0%, 0% 20%, 30% 50%, 0% 80%, 20% 100%, 50% 70%, 80% 100%, 100% 80%, 70% 50%, 100% 20%, 80% 0%, 50% 30%);</span><br></pre></td></tr></table></figure>
<p> <div style="display:flex;justify-content:space-around;"><img src="https://ws2.sinaimg.cn/mw690/005SNrnIgy1g1hez6l3rej309208sdi4.jpg" alt="avatart"><br> <img src="https://ws4.sinaimg.cn/mw690/005SNrnIgy1g1hf2dedn8j308x08q0vd.jpg" alt="avatart"><br> </div></p>
<h2 id="5-其他属性"><a href="#5-其他属性" class="headerlink" title="5.其他属性"></a>5.其他属性</h2><p>除了<code>inset</code>，<code>circle</code>，<code>ellipse</code>，<code>polygon</code>属性外，<code>clip-path</code>还具有<code>url</code>，<code>geometry-box</code>等属性值，具体可以参考<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path" target="_blank">MDN</a></p>
<h1 id="三-兼容性"><a href="#三-兼容性" class="headerlink" title="三.兼容性"></a>三.兼容性</h1><p><img src="https://wx4.sinaimg.cn/large/005SNrnIgy1g1hfchdbflj30z5073gm1.jpg" alt="avatart"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用操作</title>
    <url>/2019/07/02/git-operating/</url>
    <content><![CDATA[<h1 id="一-clone-项目"><a href="#一-clone-项目" class="headerlink" title="一.clone 项目"></a>一.clone 项目</h1><p>clone git上的项目,如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:ymtonny/myBlog.git</span><br></pre></td></tr></table></figure></p>
<h1 id="二-管理分支"><a href="#二-管理分支" class="headerlink" title="二.管理分支"></a>二.管理分支</h1><h2 id="1-查看分支"><a href="#1-查看分支" class="headerlink" title="1.查看分支"></a>1.查看分支</h2><a id="more"></a>
<h3 id="1-1-查看本地分支"><a href="#1-1-查看本地分支" class="headerlink" title="1.1.查看本地分支"></a>1.1.查看本地分支</h3><p>使用git branch命令,如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch </span><br><span class="line">* master</span><br></pre></td></tr></table></figure></p>
<p>*标识的是你当前所在的分支</p>
<h3 id="1-2-查看远程分支"><a href="#1-2-查看远程分支" class="headerlink" title="1.2.查看远程分支"></a>1.2.查看远程分支</h3><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3-查看所有分支"><a href="#1-3-查看所有分支" class="headerlink" title="1.3.查看所有分支"></a>1.3.查看所有分支</h3><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure></p>
<h2 id="2-本地创建新分支"><a href="#2-本地创建新分支" class="headerlink" title="2.本地创建新分支"></a>2.本地创建新分支</h2><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch [branch name]</span><br></pre></td></tr></table></figure></p>
<h2 id="3-切换到新分支"><a href="#3-切换到新分支" class="headerlink" title="3.切换到新分支"></a>3.切换到新分支</h2><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout [branch name]</span><br></pre></td></tr></table></figure></p>
<h2 id="4-创建-切换分支"><a href="#4-创建-切换分支" class="headerlink" title="4.创建+切换分支"></a>4.创建+切换分支</h2><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b [branch name]</span><br></pre></td></tr></table></figure></p>
<h2 id="5-将新分支上传到远程分支中"><a href="#5-将新分支上传到远程分支中" class="headerlink" title="5.将新分支上传到远程分支中"></a>5.将新分支上传到远程分支中</h2><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin [branch name]</span><br></pre></td></tr></table></figure></p>
<h2 id="6-删除本地分支"><a href="#6-删除本地分支" class="headerlink" title="6.删除本地分支"></a>6.删除本地分支</h2><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d [branch name]</span><br></pre></td></tr></table></figure></p>
<h2 id="7-删除远程分支"><a href="#7-删除远程分支" class="headerlink" title="7.删除远程分支"></a>7.删除远程分支</h2><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin :[branch name]</span><br></pre></td></tr></table></figure></p>
<p>分支名前冒号代表删除。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题 --vue</title>
    <url>/2019/06/20/interview/</url>
    <content><![CDATA[<h3 id="1-说一下Vue的双向绑定数据的原理"><a href="#1-说一下Vue的双向绑定数据的原理" class="headerlink" title="1. 说一下Vue的双向绑定数据的原理"></a>1. 说一下Vue的双向绑定数据的原理</h3><p><code>vue</code> 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 <code>Object.defineProperty()</code> 来劫持各个属性的 <code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应监听回调</p>
<a id="more"></a>
<h3 id="2-解释单向数据流和双向数据绑定"><a href="#2-解释单向数据流和双向数据绑定" class="headerlink" title="2. 解释单向数据流和双向数据绑定"></a>2. 解释单向数据流和双向数据绑定</h3><p> 单向数据流： 顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使UI发生变更就必须创建各种 <code>action</code> 来维护对应的 <code>state</code></p>
<p> 双向数据绑定：数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时 <code>debug</code> 的难度</p>
<h3 id="3-Vue-如何去除url中的"><a href="#3-Vue-如何去除url中的" class="headerlink" title="3. Vue 如何去除url中的 #"></a>3. Vue 如何去除url中的 <code>#</code></h3><p><code>vue-router</code> 默认使用 <code>hash</code> 模式，所以在路由加载的时候，项目中的 <code>url</code> 会自带 <code>#</code>。如果不想使用 <code>#</code>， 可以使用 <code>vue-router</code> 的另一种模式 <code>history</code><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">new Router(&#123;</span><br><span class="line">      mode: <span class="string">'history'</span>,</span><br><span class="line">      routes: [ ]</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，当我们启用 <code>history</code>模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现<code>404</code>的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 <code>URL</code> 匹配不到任何静态资源，则应该返回同一个 <code>index.html</code> 页面</p>
<h3 id="4-vue生命周期理解"><a href="#4-vue生命周期理解" class="headerlink" title="4.vue生命周期理解"></a>4.vue生命周期理解</h3><p>vue实例有一个完整的生命周期，生命周期也就是指一个实例从开始创建到销毁的这个过程</p>
<ul>
<li><code>beforeCreated()</code> 在实例创建之间执行，数据未加载状态 <code>created()</code></li>
<li>在实例创建、数据加载后，能初始化数据，dom渲染之前执行 </li>
<li><code>beforeMount()</code> 虚拟<code>dom</code>已创建完成，在数据渲染前最后一次更改数据</li>
<li><code>mounted()</code> 页面、数据渲染完成，真实dom挂载完成 </li>
<li><code>beforeUpadate()</code> 重新渲染之前触发 <code>updated()</code></li>
<li>数据已经更改完成，<code>dom</code> 也重新 <code>render</code> 完成,更改数据会陷入死循环 </li>
<li><code>beforeDestory()</code> 和 <code>destoryed()</code>前者是销毁前执行（实例仍然完全可用），后者则是销毁后执行</li>
</ul>
<h3 id="5-v-if和v-show区别"><a href="#5-v-if和v-show区别" class="headerlink" title="5.v-if和v-show区别"></a>5.v-if和v-show区别</h3><p> 使用了 <code>v-if</code> 的时候，如果值为 <code>false</code> ，那么页面将不会有这个 <code>html</code> 标签生成。</p>
<p> <code>v-show</code> 则是不管值为 <code>true</code> 还是 <code>false</code> ，<code>html</code> 元素都会存在，只是 <code>CSS</code> 中的 <code>display</code> 显示或隐藏</p>
<h3 id="6-route和-router的区别"><a href="#6-route和-router的区别" class="headerlink" title="6. $route和$router的区别"></a>6. <code>$route</code>和<code>$router</code>的区别</h3><p> <code>$router</code> 为 <code>VueRouter</code> 实例，想要导航到不同 <code>URL</code>，则使用 <code>$router.push</code> 方法</p>
<p> <code>$route</code> 为当前 <code>router</code> 跳转对象里面可以获取 <code>name</code> 、 <code>path</code> 、 <code>query</code> 、 <code>params</code> 等</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript数据属性和访问器属性</title>
    <url>/2019/06/19/javascript/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<code>javascript</code>中，我们访问对象的时候可以直接通过<code>obj.name</code>进行访问，删除时可以直接通过<code>delete obj.name</code>进行删除，那么你真的知道它为什么能直接访问或则删除么？如果你知道<code>javascript</code>中的数据属性，那就自然知道为什么能访问了；如果不知道呢，咱就接着往下看。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">   name:&quot;abc&quot;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.name)</span><br></pre></td></tr></table></figure></p>
<h2 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h2><p>在<code>javascript</code>中数据属性分为以下几种：</p>
<ul>
<li><code>configurable</code>:表示能否通过delete删除属性，从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为true。</li>
<li><code>enumerable</code>:表示能否通过<code>fon-in</code>循环返回属性，默认为true。</li>
<li><code>writable</code>:表示能否修改属性的值，默认为true。</li>
<li><code>value</code>:表示属性的数据值。默认为undefind。</li>
</ul>
<p>接下来我们尝试理解上面的含义，首先创建一个对象：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  name:&quot;张三&quot;,</span><br><span class="line">  age:12</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-configurable"><a href="#1-configurable" class="headerlink" title="1.configurable"></a>1.configurable</h3><p>根据configurable的定义，我们通过<code>Object.defineProperty</code>修改obj的name属性的数据属性<code>configurable</code>为false<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.defineProperty(obj,&quot;name&quot;,&#123;</span><br><span class="line"> configurable:false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据上面的定义，我们把configurable设为false时，我们不能通过delete进行删除属性,不能修改属性的特性，不能把属性修改为访问器属性。<br>删除属性：<br><img src="http://wx1.sinaimg.cn/large/005SNrnIgy1g281hehvbwj30cr064mx9.jpg" alt="image"><br>修改属性特性：<br><img src="http://wx4.sinaimg.cn/large/005SNrnIgy1g281m3gn70j30b70353yg.jpg" alt="image"><br>当我们把configurable属性修改为false的时候就不能再改回为true了，同时修改enumerable属性也会受到限制，当尝试修改时会报错。</p>
<h3 id="2-enumerable"><a href="#2-enumerable" class="headerlink" title="2.enumerable"></a>2.enumerable</h3><p>根据上面的定义，我们重新定义并修改name属性的enumerable为false，然后用for in遍历属性对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.defineProperty(obj,&quot;name&quot;,&#123;</span><br><span class="line">  enumerable:false</span><br><span class="line">&#125;)</span><br><span class="line">for(let key in obj)&#123;</span><br><span class="line">  console.log(key+&quot;--&quot;+obj[key])</span><br><span class="line">&#125;</span><br><span class="line">//输出</span><br><span class="line">age--12</span><br></pre></td></tr></table></figure></p>
<p>因为属性name的enumerable修改为了false,所以当我们用for in循环遍历obj对象时，我们无法遍历到name属性，所以上面代码只会打印age属性。</p>
<h3 id="3-writable和value"><a href="#3-writable和value" class="headerlink" title="3.writable和value"></a>3.writable和value</h3><p>value属性的值是否能被修改是根据writable确定的，当我们把writable的值设为true的时候，value可以被修改，否在反之。<br><img src="http://wx1.sinaimg.cn/large/005SNrnIgy1g2821jk29pj30by05jdfu.jpg" alt="image"><br>所以，当writable为false时，我们不能修改属性值，这里需要注意的是，如果configurable为false，此时我们可以将writable,但如果再设回为true就会报错。</p>
<h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p>访问器属性一共有四个，分别为<code>configurable</code>,<code>enumerable</code>,<code>get</code>,<code>set</code>，其中configurable和enumerable和数据属性中的是一样的，这里就不再进行说明</p>
<ul>
<li>get:在读取属性的时候会调用，默认值为undefind。</li>
<li>set:在设置属性的时候会调用，默认为undefind。</li>
</ul>
<p>同样的我们可以通过<code>Object.defineProperty</code>对访问器属性进行设定。有兴趣的小伙伴下来自己试试吧，今天没时间啦(<em>^_^</em>)。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>electron打包react项目</title>
    <url>/2019/06/13/electron-packager/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>懂的小伙伴大概已经知道这是个什么了，那么不懂的小伙伴听我大致道来。也许你不甘心只写网页，也想写一个电脑上的exe程序那种；或者你有项目需求必须要写个exe程序，但是你只会前端，没关系，看了这篇文章你也就能写出一个exe程序了。<br><a id="more"></a></p>
<h2 id="一、安装electron"><a href="#一、安装electron" class="headerlink" title="一、安装electron"></a>一、安装electron</h2><ul>
<li>为了方便以后使用，建议进行全局安装，这样任何文件夹下面就都能使用<code>electron</code>了。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//安装命令</span><br><span class="line">npm install electron  --g</span><br><span class="line">//npm如果太慢的话，我们就改用国内镜像，国内镜像安装如下:</span><br><span class="line">npm install cnpm -g  --registry=https://registry.npm.taobao.org</span><br><span class="line">cnpm install electron --save</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、react使用electron"><a href="#二、react使用electron" class="headerlink" title="二、react使用electron"></a>二、react使用electron</h2><h3 id="添加electron包"><a href="#添加electron包" class="headerlink" title="添加electron包"></a>添加electron包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install electron --save</span><br><span class="line">//安装打包工具</span><br><span class="line">npm install electron-packager --save-dev</span><br></pre></td></tr></table></figure>
<h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><h4 id="配置main-js"><a href="#配置main-js" class="headerlink" title="配置main.js"></a>配置main.js</h4><p>在项目根目录(不是src目录)下新建一个main.js，写入如下配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//引入electron并创建一个BrowserWindow</span><br><span class="line">const &#123;app,BrowserWindow&#125; = require(&quot;electron&quot;);</span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">const url = require(&quot;path&quot;);</span><br><span class="line">//保持window对象的全局引用，避免Javascript对象被垃圾回收时，窗口被自动关闭</span><br><span class="line">let win;</span><br><span class="line"></span><br><span class="line">function createWindow()&#123;</span><br><span class="line"> //创建浏览器窗口，宽高随意</span><br><span class="line">  win = new BrowserWindow(&#123;width:800,height:600&#125;);</span><br><span class="line"> </span><br><span class="line"> //加载应用----  适用桌面应用</span><br><span class="line"> /*win.loadURL(url.format(&#123;</span><br><span class="line">   pathname:path.join(_dirname+&quot;./build/index.html&quot;),</span><br><span class="line">   protocol:&quot;file:&quot;</span><br><span class="line">   slashes:true</span><br><span class="line"> &#125;))*/</span><br><span class="line"> // 加载应用---- 适用react</span><br><span class="line"> win.loadURL(&quot;http://localhost:3000/&quot;);</span><br><span class="line"> //打开开发者工具,默认不打开</span><br><span class="line"> win.webContents.openDevTools();</span><br><span class="line"> </span><br><span class="line"> //关闭window时触发</span><br><span class="line"> win.on(&quot;closed&quot;,function()&#123;</span><br><span class="line">   win = null</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//当electron初始化完成后并开始创建浏览器窗口时运行</span><br><span class="line">app.on(&quot;ready&quot;,createWindow);</span><br><span class="line"></span><br><span class="line">//所有窗口关闭时，退出应用</span><br><span class="line">app.on(&quot;window-all-closed&quot;,function(&#123;</span><br><span class="line">// macOS中除非用户按下 `Cmd + Q` 显式退出,否则应用与菜单栏始终处于活动状态.</span><br><span class="line">  if (process.platform !== &apos;darwin&apos;) &#123;</span><br><span class="line">    app.quit()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.on(&apos;activate&apos;, function () &#123;</span><br><span class="line">   // macOS中点击Dock图标时没有已打开的其余应用窗口时,则通常在应用中重建一个窗口</span><br><span class="line">  if (win === null) &#123;</span><br><span class="line">    createWindow()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="配置package-json"><a href="#配置package-json" class="headerlink" title="配置package.json"></a>配置package.json</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;platform&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;This is a food and beverage management system&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;main.js&quot;, //配置electron启动文件</span><br><span class="line">  &quot;homepage&quot;: &quot;.&quot;, //配置electron打包后静态static不能访问</span><br><span class="line">  &quot;DEV&quot;:false,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;babel-node devServer.js --progress --colors&quot;,</span><br><span class="line">    &quot;dist&quot;: &quot;webpack --config webpack.config.pro.js --progress --colors &quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack --progress&quot;,</span><br><span class="line">    &quot;electron-start&quot;: &quot;electron .&quot;, //配置运行桌面应用指令</span><br><span class="line">    //配置打包为桌面应用指令</span><br><span class="line">    &quot;packager&quot;: &quot;electron-packager ./ react-electron --win --out ~/ --electron-version 1.7.10&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;babel-node devServer.js --progress --colors ./node_modules/.bin/electron ./main&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h3 id="开始打包"><a href="#开始打包" class="headerlink" title="开始打包"></a>开始打包</h3><p>在项目根目录运行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run packager</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是回流与重绘</title>
    <url>/2019/05/24/reflux/</url>
    <content><![CDATA[<p>要想知道什么是回流与重绘，首先我们得清楚浏览器的渲染过程。你知道是渲染过程是怎样的么？下面和我一起了解一下吧。<br><a id="more"></a></p>
<h1 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h1><ol>
<li>首先，解析<code>html</code>生成<code>DOM</code>树，解析<code>css</code>生成<code>CSSOM</code>树。</li>
<li>将<code>DOM</code>树和<code>CSSOM</code>树相结合生成渲染树(<code>Render Tree</code>)。</li>
<li>根据生成的渲染树，进行回流得到节点的位置、大小等信息。</li>
<li>根据渲染树以及回流得到的几何信息，得到节点的绝对像素。</li>
<li>将像素发给<code>GPU</code>，展示在页面上。</li>
</ol>
<p>渲染过程看起来虽然很简单，但是具体做了什么可能还不是太清楚吧，下面我们一一了解下。</p>
<h1 id="生成渲染树"><a href="#生成渲染树" class="headerlink" title="生成渲染树"></a>生成渲染树</h1><p>为了生成渲染树，浏览器主要做了以下工作：</p>
<ol>
<li>从<code>DOM</code>树的根节点开始遍历每个可见的节点。</li>
<li>对于每一个可见的节点，找到<code>CSSOM</code>树中的对应规则，并应用它们。</li>
<li>根据每一个可见的节点以及它们所对应的样式，组合生成渲染树。</li>
</ol>
<h4 id="注意：渲染树只包含可见节点。"><a href="#注意：渲染树只包含可见节点。" class="headerlink" title="注意：渲染树只包含可见节点。"></a>注意：渲染树只包含可见节点。</h4><p>不可见的节点包括：</p>
<ul>
<li>不会渲染输出的节点。如<code>script</code>、<code>meta</code>、<code>link</code>等标签。</li>
<li>通过css属性进行隐藏的节点，如<code>display:none</code>。（用<code>visibility</code>和<code>opacity</code>隐藏的节点还是会渲染到渲染树上。）</li>
</ul>
<h1 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h1><p>前面我们已经通过构造渲染树，将可见的节点以及它所对应的样式相结合起来，但是我们还需要计算每个节点在设备视图里所在的具体位置及大小。这个计算的过程我们就称为回流。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;title&gt;Critial Path: Hello world!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div style=&quot;width: 50%&quot;&gt;</span><br><span class="line">      &lt;div style=&quot;width: 50%&quot;&gt;Hello world!&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>以上代码中，我们可以看到第一个<code>div</code>将显示的尺寸设为了设备视窗的50%,第二个<code>div</code>设为了父节点宽度的50%，在回流的阶段我们就需要根据视窗的具体宽度，将其设为具体的像素值。</p>
<h1 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h1><p>我们通过构造渲染树和回流的阶段，知道了哪些节点是可见的，以及可见节点的样式和具体位置和大小信息，那么我们就可以将渲染树中的每一个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘。</p>
<h1 id="何时发生回流和重绘"><a href="#何时发生回流和重绘" class="headerlink" title="何时发生回流和重绘"></a>何时发生回流和重绘</h1><p>通过前面我们知道，回流主要是计算节点在设备上显示的具体位置及大小，那么当页面发生变化的时候就会触发回流。如：</p>
<ul>
<li>添加或删除可见的<code>DOM</code>元素。</li>
<li>元素的位置发生变化。</li>
<li>元素的尺寸发生变化（包括边框、边距、大小等）。</li>
<li>元素的文本内容发生变化。</li>
<li>浏览器的窗口大小发生改变（因为回流是根据视窗的大小来计算节点的具体位置的）。<h4 id="注意：回流一定会触发重绘，而重绘不一定会触发回流。"><a href="#注意：回流一定会触发重绘，而重绘不一定会触发回流。" class="headerlink" title="注意：回流一定会触发重绘，而重绘不一定会触发回流。"></a>注意：回流一定会触发重绘，而重绘不一定会触发回流。</h4></li>
</ul>
]]></content>
      <tags>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title>关于vuex</title>
    <url>/2019/05/05/vue-interview/</url>
    <content><![CDATA[<h2 id="vuex数据流"><a href="#vuex数据流" class="headerlink" title="vuex数据流"></a>vuex数据流</h2><p>说实话，看了官方文档我并不清楚vuex到底是个什么东西，通过例子，我知道如何使用后，我才慢慢理解一点。我的理解就是：为什么会存在组件不能通信？简单粗暴的回答就是，变量的作用域导致的，vue的每一个组件都有自己的生命周期，都是独立存在的个体。vuex就是在根组件创建一个叫state的全局变量，让不同组件共享这个变量，并且定义了一系列方法和规范，也就是action、mutation等等，去统一触发这个全局变量也就是state。<br><a id="more"></a></p>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// store/index.js</span><br><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line">import Vuex from <span class="string">'vuex'</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  <span class="function"><span class="title">state</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      monitorInfo: &#123;</span><br><span class="line">        name: <span class="string">''</span>,</span><br><span class="line">        description: <span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    updateMonitorInfo: (&#123;commit&#125;, info) =&gt; &#123;</span><br><span class="line">      commit(<span class="string">'UPDATE_MONITOR_INFO'</span>, info)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    UPDATE_MONITOR_INFO: (state, info) =&gt; &#123;</span><br><span class="line">      window.localStorage.setItem(<span class="string">'monitorInfo'</span>, JSON.stringify(info))</span><br><span class="line">      state.monitorInfo = info</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    monitorInfo: (state) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!state.monitorInfo.name) &#123;</span><br><span class="line">        state.monitorInfo = JSON.parse(window.localStorage.getItem(<span class="string">'monitorInfo'</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> state.monitorInfo</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">export</span> default store</span><br></pre></td></tr></table></figure>
<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- list 兄弟组件的发送方--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; mapActions &#125; from &apos;vuex&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      ...mapActions([&apos;updateMonitorInfo&apos;]),</span><br><span class="line">      goNextPage (row, routerName) &#123;</span><br><span class="line">        let monitorInfo = &#123;</span><br><span class="line">          name: row.name,</span><br><span class="line">          serviceUrl: row.serviceUrl,</span><br><span class="line">          description: row.info.description</span><br><span class="line">        &#125;</span><br><span class="line">        this.updateMonitorInfo(monitorInfo)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- monitor.vue  兄弟组件接收方--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;span&gt;&#123;monitorInfo.name&#125;&lt;/span&gt;</span><br><span class="line">  &lt;span&gt;&#123;monitorInfo.description&#125;&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; mapGetters &#125; from &apos;vuex&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      ...mapGetters([&apos;monitorInfo&apos;])</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;   </span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖与节流</title>
    <url>/2019/04/28/vue-shake/</url>
    <content><![CDATA[<h2 id="什么是节流与防抖呢"><a href="#什么是节流与防抖呢" class="headerlink" title="什么是节流与防抖呢"></a>什么是节流与防抖呢</h2><p>在开发环境中，我们经常会遇见这样的问题，一个按钮连续点击就会连续调用<code>api</code>，从而使之出现不必要的麻烦。那么我们要怎么解决这样的问题呢？解决方法有很多，但是这里我想说的是利用函数防抖与节流来解决这样的问题，至于为什么我要使用防抖与节流来解决这样的问题看了下面你们就知道啦。</p>
<ul>
<li>函数防抖： 一个任务频繁触发的情况下，只有任务触发的间隔时间超过指定间隔的时候，任务才会去执行。</li>
<li>函数节流：在指定的时间间隔里只会去执行一次任务。<a id="more"></a>
<h2 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流(throttle)"></a>函数节流(throttle)</h2>在这里我以判断页面滚动到底部为例，平常普通的做法就是通过监听 <code>window</code> 的 <code>scroll</code> 事件，然后在函数体内写入判断是否滚动到底部的逻辑：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(window).on(&quot;scroll&quot;,function()&#123;</span><br><span class="line">  //判断是否滚动到底部逻辑,只要浏览器滚动就会进入此函数体</span><br><span class="line">  let pageHeight = $(&quot;body&quot;).height(), //页面高度</span><br><span class="line">      scrollTop = $(window).scrollTop(), //滚动条距离顶部的距离</span><br><span class="line">      winHeight = $(window).height(),  //浏览器窗口的高度</span><br><span class="line">      thred = pageHeight - scrollTop - winHeight;</span><br><span class="line">      if(thred &gt; -100 &amp;&amp; thred &lt;=20)&#123;</span><br><span class="line">        console.log(end)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样做的话有一个缺点就是耗性能，因为在滚动的时候，浏览器无时无刻都在计算着滚动条是否滚动到底部的逻辑，然而在实际场景中我们并不需要这样做，实际上工作中我们可能是这样：在滚动的过程中，隔一段时间再去计算滚动到底部的逻辑。而函数节流所做的工作就是每隔一段时间就去执行一次原本无时无刻执行的函数。所以在滚动中用它是不错的选择：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Throttling(fn,time = 1000)&#123;</span><br><span class="line">  let timer = null;  // 保存此标记判读是否执行函数</span><br><span class="line">  return function()&#123;</span><br><span class="line">    if(!timer) &#123;</span><br><span class="line">        timer = setTimeout(()=&gt;&#123;</span><br><span class="line">          fn.apply(this,arguments);</span><br><span class="line">         timer = null;// 这里设置为null，是为了实现滚动经过400ms过后再次执行函数</span><br><span class="line">        &#125;,time)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用方法</span><br><span class="line">$(windwo).on(&quot;scroll&quot;,Throttling(</span><br><span class="line"> function()&#123;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line">),400)</span><br></pre></td></tr></table></figure></p>
<h2 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h2><p>在这里我以注册用户为例,大多数网站的验证用户是否被注册都是通过 <code>input</code> 框中输入的时候去验证是否被注册，而不是在 <code>input</code> 失去焦点的时候去验证，大概是为了提高用户体验而这样做的吧。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.username&quot;).on(&quot;input&quot;,function()&#123;</span><br><span class="line"> $.ajax(&#123;</span><br><span class="line">   ...</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>显而易见这样的做法是不好的，当用户在 <code>input</code> 框中输入每一个字符时都会去调用后台接口验证用户是否被注册，这样不仅对服务器的压力增加，同时体验反而也没有原本的失去焦点效果好。理想的做法就是，当用户输入第一个字符过后的一段时间内如果还有字符输入的话，就暂时不去请求后台<code>api</code>验证用户是否被注册,函数防抖就是为了解决这样的问题。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(fn,time = 1000)&#123;</span><br><span class="line">  let timer;</span><br><span class="line">  return function()&#123;</span><br><span class="line">     clearTimeout(timer); // 当键盘连续输入时候,不执行函数</span><br><span class="line">     timer = setTimeout(()=&gt;&#123;</span><br><span class="line">       fn.apply(this,arguments);//传入this,是为了让fn函数中的this指向.apply中的第一个参数</span><br><span class="line">     &#125;,time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用方法</span><br><span class="line">$(&quot;.username&quot;).on(&quot;input&quot;,debounce(function()&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue路由归纳</title>
    <url>/2019/04/05/vue-router/</url>
    <content><![CDATA[<h2 id="vue路由的原理"><a href="#vue路由的原理" class="headerlink" title="vue路由的原理"></a>vue路由的原理</h2><p>单页面的一大优势就是，无刷新跳转页面，用户体验好，加载速度快。vue路由的跳转它是无刷新的，共有两种模式，可以通过路由配置文件中去配置<code>mode</code>字段，如果不去配置这个<code>mode</code>字段，默认路由跳转就为<code>hash</code>模式。</p>
<p><code>hash</code>模式，通过在链接后面添加”#”号+路由名字，匹配这个字段的变化去触发<code>hashchange</code>事件，动态的渲染出页面。</p>
<p>另外一种模式为<code>history</code>模式，即使用浏览器的historyAPI,<code>pushState</code>和<code>replaceState</code>。通过调用<code>pushState</code>去操作浏览器的<code>history</code>对象，改变当前链接地址，同时结合<code>window.onpopstate</code>监控浏览器的返回前进事件，同样可以实现无刷新的跳转页面。<code>replaceState</code>和<code>pushState</code>的区别就是，前者代表替换，后者代表插入。</p>
<a id="more"></a>
<p><code>history</code>相对于<code>hash</code>，就是没有”#”号，看着十分清爽。但是用hash模式的反而较多，为什么呢？因为<code>history</code>模式还需要后端的配置，否则刷新页面就会返回404。</p>
<h2 id="vue路由两种传参"><a href="#vue路由两种传参" class="headerlink" title="vue路由两种传参"></a>vue路由两种传参</h2><p>页面传参就两种，<code>params</code>和<code>query</code>,<code>params</code>是以<code>/params</code>方式展示，<code>query</code>是以<code>/?query=</code>方式展示。写法大致都是相同，不过<code>query</code>是用<code>path</code>来引入，而<code>params</code>是用<code>name</code>来引入。注意：接收参数的时候是用<code>route</code>而不是<code>router</code>。<code>query</code>像是ajax中的get,而<code>params</code>更像是post,刷新页面时<code>params</code>参数会丢失,而<code>query</code>参数不会丢失。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//query</span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">  path:&quot;/abc&quot;,</span><br><span class="line">  query:&#123;id:id&#125;</span><br><span class="line">&#125;);</span><br><span class="line">//params</span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">   name:&quot;abc&quot;</span><br><span class="line">   params:&#123;id:id&#125;</span><br><span class="line">&#125;);</span><br><span class="line">//接收参数</span><br><span class="line">this.$route.query.name</span><br><span class="line">this.$route.params.name</span><br></pre></td></tr></table></figure></p>
<h2 id="vue路由跳转"><a href="#vue路由跳转" class="headerlink" title="vue路由跳转"></a>vue路由跳转</h2><p>vue 路由的跳转分成两种，一种是声明式，使用<code>&lt;router-link&gt;</code>声明跳转，<code>to</code>属性定义跳转的参数。另一种是编程式，使用 <code>router.go()</code>、<code>router.push()</code>、<code>router.replace()</code>方法进行跳转，<code>go</code>方法就是与浏览器的history api 的方法相同，可以进行返回上一页等操作。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">router.push(&apos;home&apos;)</span><br><span class="line"></span><br><span class="line">// 对象</span><br><span class="line">this.$router.push(&#123;path: &apos;home&apos;&#125;)</span><br><span class="line"></span><br><span class="line">//命名的路由</span><br><span class="line">this.$router.push(&#123;name: &apos;user&apos;, params: &#123;userId: 123&#125;&#125;)</span><br><span class="line"></span><br><span class="line">// 带查询参数，变成/register?plan=private</span><br><span class="line">this.$router.push(&#123;path: &apos;register&apos;, query: &#123;plan: &quot;private&quot;&#125;&#125;);</span><br><span class="line"></span><br><span class="line">//声明式</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:&apos;abc&apos;,params:&#123;id:id&#125;&#125;&quot;&gt;&lt;/route-link&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="vue路由守卫"><a href="#vue路由守卫" class="headerlink" title="vue路由守卫"></a>vue路由守卫</h2><p>vue路由守卫分3种，一种是全局路由守卫，通常在实例化路由之后设置，做通用路由的设置，它所有的路由跳转全部都会执行的操作；一种是单独的路由独享守卫，在单个路由定义的时候设置，所有跳转到这个路由的都会执行，一种是组件内的路由守卫，只在组件内生效。</p>
<p> 全局路由守卫：</p>
<ul>
<li><code>router.beforeEach(to,from,next)</code></li>
<li><code>router.afterEach(to,from,next)</code></li>
</ul>
<p>路由独享守卫：</p>
<ul>
<li><code>beforeEnter(to,from,next)</code></li>
</ul>
<p>组件内守卫：</p>
<ul>
<li><code>beforeRouteEnter(to,from,next)</code></li>
<li><code>beforeRouteUpdate(to,from,next)</code>  //动态参数路径改变时，组件实例被复用的时候调用</li>
<li><code>beforeRouteLeave(to,from,next)</code>   //导航离开组件所在路由时被调用</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>for循环应该这么用</title>
    <url>/2019/03/05/for/</url>
    <content><![CDATA[<p>从最开始学的for循环的遍历方法，再到后来连续不断出来的各种循环遍历方法，其实最大的区别就是应用的场景不同。而我们需要知道的是，什么情况下用哪一种方法合适</p>
<hr>
<a id="more"></a>
<p>下面我就以例子介绍每种方法再什么情况下用最合适：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [</span><br><span class="line"> &#123;id:&quot;1&quot;,money:10&#125;,</span><br><span class="line"> &#123;id:&quot;2&quot;,money:30&#125;,</span><br><span class="line"> &#123;id:&quot;3&quot;,money:40&#125;,</span><br><span class="line"> &#123;id:&quot;4&quot;,money:50&#125;,</span><br><span class="line"> &#123;id:&quot;5&quot;,money:60&#125;,</span><br><span class="line"> &#123;id:&quot;6&quot;,money:80&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<h2 id="1-给每一组数据的money都增大一点"><a href="#1-给每一组数据的money都增大一点" class="headerlink" title="1.给每一组数据的money都增大一点"></a>1.给每一组数据的<code>money</code>都增大一点</h2><p>这个时候可用到<code>forEach</code>方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.forEach(item =&gt; &#123; item.money += 10 &#125;));</span><br></pre></td></tr></table></figure></p>
<p><code>map</code>方法它说它也可以:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.map(item =&gt; &#123; item.money += 10 &#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>map</code>补充说，我还可以给你把money统计成一个新的数组给你；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let money = arr.map(item =&gt; &#123; return item.money += 10 &#125;);</span><br><span class="line">//[20,40,50,60,70,90]</span><br></pre></td></tr></table></figure></p>
<p>###<code>forEach</code>和<code>map</code>最大的区别就在于<code>forEach</code>没有返回值。</p>
<h2 id="2-只要这组数据中money大于50的数据（筛选）"><a href="#2-只要这组数据中money大于50的数据（筛选）" class="headerlink" title="2.只要这组数据中money大于50的数据（筛选）"></a>2.只要这组数据中money大于50的数据（筛选）</h2><p>从题目看就知道，筛选这种事一般都是<code>filter</code>来做的:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let filones = arr.filter(item =&gt; &#123; return item.money&gt;=50 &#125;);</span><br><span class="line">//[&#123;id:&quot;4&quot;,money:50&#125;,&#123;id:&quot;5&quot;,money:60&#125;,&#123;id:&quot;6&quot;,money:80&#125;]</span><br></pre></td></tr></table></figure></p>
<h2 id="3-这组数据中有money大于50的么-（有符合）"><a href="#3-这组数据中有money大于50的么-（有符合）" class="headerlink" title="3.这组数据中有money大于50的么 （有符合）"></a>3.这组数据中有money大于50的么 （有符合）</h2><p>这题意思就是，这组数据只要有money大于50的就符合，这个时候<code>some</code>就很有用了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let flag = arr.some(item =&gt; &#123; return item.money&gt;50 &#125;);</span><br><span class="line">//true</span><br></pre></td></tr></table></figure></p>
<p><code>some</code>它会去遍历查找满足条件的，当第一条就符合的时候，就会立即返回告诉你有符合的了，后面的就不用检查了。</p>
<h2 id="4-这组数据中money全是大于50的么？"><a href="#4-这组数据中money全是大于50的么？" class="headerlink" title="4.这组数据中money全是大于50的么？"></a>4.这组数据中money全是大于50的么？</h2><p>这个时候every就想知道这组数据中难道每条都大于50？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let flag = arr.every(item =&gt; &#123;return item.money&gt;50 &#125;)</span><br><span class="line">//false</span><br></pre></td></tr></table></figure></p>
<p>当每条数据都要去检查的时候，像这样会非常耗费性能;我们可以考虑反向检查，通过<code>some</code>检查是否有小于50的数据，再取反。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let flag = !arr.some(item =&gt; &#123;return item.money&lt;50 &#125;);</span><br><span class="line">//false</span><br></pre></td></tr></table></figure></p>
<h2 id="5-这组数据money总和是多少呢"><a href="#5-这组数据money总和是多少呢" class="headerlink" title="5.这组数据money总和是多少呢"></a>5.这组数据money总和是多少呢</h2><p>我们可以先通过用<code>map</code>将<code>money</code>取出来，再用<code>reduce</code>计算其总和。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let moneys = arr.map(item =&gt; &#123;return item.money &#125;);</span><br><span class="line">let sum = moneys.reduce((sum,moneys)=&gt;&#123; return moneys+sum&#125;,0)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>代码评审清单</title>
    <url>/2018/12/12/CodecheckList/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="前端团队根据情况有时候会有评审代码的要求，但是由于每个开发人员的技术水平不同，代码风格不同，所关注的技术点也不同，为了保证代码的质量以及团队的代码风格统一，因此产生了团队中的CodeReview-为此拟了一份清单-如果你的团队还没有CodeReview，可能这正是你需要的。"><a href="#前端团队根据情况有时候会有评审代码的要求，但是由于每个开发人员的技术水平不同，代码风格不同，所关注的技术点也不同，为了保证代码的质量以及团队的代码风格统一，因此产生了团队中的CodeReview-为此拟了一份清单-如果你的团队还没有CodeReview，可能这正是你需要的。" class="headerlink" title="前端团队根据情况有时候会有评审代码的要求，但是由于每个开发人员的技术水平不同，代码风格不同，所关注的技术点也不同，为了保证代码的质量以及团队的代码风格统一，因此产生了团队中的CodeReview,为此拟了一份清单,如果你的团队还没有CodeReview，可能这正是你需要的。"></a>前端团队根据情况有时候会有评审代码的要求，但是由于每个开发人员的技术水平不同，代码风格不同，所关注的技术点也不同，为了保证代码的质量以及团队的代码风格统一，因此产生了团队中的CodeReview,为此拟了一份清单,如果你的团队还没有CodeReview，可能这正是你需要的。</h4><h2 id="一、代码静态检查工具"><a href="#一、代码静态检查工具" class="headerlink" title="一、代码静态检查工具"></a>一、代码静态检查工具</h2><h3 id="1-1、使用eslint工具对javascript代码进行检查。"><a href="#1-1、使用eslint工具对javascript代码进行检查。" class="headerlink" title="1.1、使用eslint工具对javascript代码进行检查。"></a>1.1、使用eslint工具对javascript代码进行检查。</h3><p><code>eslint</code>检查的规范继承自<code>eslint-config-standard</code>检验规则。<br><a id="more"></a></p>
<h3 id="1-2、使用stylelint工具对css样式代码进行检查。"><a href="#1-2、使用stylelint工具对css样式代码进行检查。" class="headerlink" title="1.2、使用stylelint工具对css样式代码进行检查。"></a>1.2、使用stylelint工具对css样式代码进行检查。</h3><p><code>stylelint</code>检查的规范继承自<code>stylelint-config-standard</code>检验规则。</p>
<h2 id="二、命名规范"><a href="#二、命名规范" class="headerlink" title="二、命名规范"></a>二、命名规范</h2><h3 id="2-1、JS采用Camel-Case小驼峰命名"><a href="#2-1、JS采用Camel-Case小驼峰命名" class="headerlink" title="2.1、JS采用Camel Case小驼峰命名"></a>2.1、JS采用Camel Case小驼峰命名</h3><p>推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">studentInfo</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2、避免名称冗余"><a href="#2-2、避免名称冗余" class="headerlink" title="2.2、避免名称冗余"></a>2.2、避免名称冗余</h3><p>推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Car = &#123;</span><br><span class="line">  money:123,</span><br><span class="line">  color:&quot;red&quot;,</span><br><span class="line">  name:&quot;大地&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Car = &#123;</span><br><span class="line">  Carmoney:123,</span><br><span class="line">  Carcolor:&quot;red&quot;,</span><br><span class="line">  Carname:&quot;大地&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3、CSS类名采用BEM命名规范"><a href="#2-3、CSS类名采用BEM命名规范" class="headerlink" title="2.3、CSS类名采用BEM命名规范"></a>2.3、CSS类名采用BEM命名规范</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.block_element&#123;&#125;     // 代表块block元素中的子元素element</span><br><span class="line">.block--modifier&#123;&#125;  //  代表块block元素的状态</span><br></pre></td></tr></table></figure>
<h3 id="2-4、命名符合语义化"><a href="#2-4、命名符合语义化" class="headerlink" title="2.4、命名符合语义化"></a>2.4、命名符合语义化</h3><p>命名需要符合语义化，如果是函数命名可以采用加上动词前缀<br>动词      含义<br>can       判断是否可以执行某个动作<br>has       判断是否含有某一个值<br>is          判断是否为某一个值<br>get        获取某一个值<br>set        设置某一个值<br>推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 是否显示</span><br><span class="line">function canShow()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 设置名称</span><br><span class="line">function setName()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、JS推荐写法"><a href="#三、JS推荐写法" class="headerlink" title="三、JS推荐写法"></a>三、JS推荐写法</h2><h3 id="3-1、每个常量都需要命名"><a href="#3-1、每个常量都需要命名" class="headerlink" title="3.1、每个常量都需要命名"></a>3.1、每个常量都需要命名</h3><p>每个常量应该命名，不然看代码的人不知道这个常量的意思。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const COL_NUM = 10</span><br><span class="line">let row = Math.ceil(num/COL_NUM)</span><br></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let row = Math.ceil(num/10)</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2、推荐使用字面量"><a href="#3-2、推荐使用字面量" class="headerlink" title="3.2、推荐使用字面量"></a>3.2、推荐使用字面量</h3><p>创建对象和数组推荐使用字面量，因为这不仅是性能最优也有助于节省代码量。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">   name:&quot;tonny&quot;,</span><br><span class="line">   age:12,</span><br><span class="line">   sex:&quot;男&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">obj.name = &quot;tonny&quot;</span><br><span class="line">obj.age = 12</span><br><span class="line">obj.sex = &quot;男&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3、-函数参数"><a href="#3-3、-函数参数" class="headerlink" title="3.3、 函数参数"></a>3.3、 函数参数</h3><p>函数参数越少越好，如果参数超过两个，要使用 ES6的解构语法，不用考虑参数的顺序。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createMenu(&#123;title,name,value,label&#125;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">createMenu(&#123;</span><br><span class="line">  title:&quot;ad&quot;,</span><br><span class="line">  name:&quot;tonny&quot;,</span><br><span class="line">  value:&quot;123&quot;,</span><br><span class="line">  label:&quot;button&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createMenu(title,name,value,label)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-4、使用参数默认值，代替使用条件语句进行赋值"><a href="#3-4、使用参数默认值，代替使用条件语句进行赋值" class="headerlink" title="3.4、使用参数默认值，代替使用条件语句进行赋值"></a>3.4、使用参数默认值，代替使用条件语句进行赋值</h3><p>推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function create(name=&quot;abc&quot;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function create(name)&#123;</span><br><span class="line">  let newName = name || &quot;abc&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-5、推荐使用函数式编程"><a href="#3-5、推荐使用函数式编程" class="headerlink" title="3.5、推荐使用函数式编程"></a>3.5、推荐使用函数式编程</h3><p>函数式编程可以让代码的逻辑更清晰更优雅，方便测试<br>推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const menu = [</span><br><span class="line"> &#123;name:&quot;a&quot;,size:1&#125;,</span><br><span class="line"> &#123;name:&quot;b&quot;,size:2&#125;,</span><br><span class="line"> &#123;name:&quot;c&quot;,size:3&#125;</span><br><span class="line">]</span><br><span class="line">let sumMenu = menu.map(item =&gt; item.size).reduce((prevsize,nextsize)=&gt; previse+nextsize,0);</span><br></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sum = 0;</span><br><span class="line">for(let i=0;i&lt;menu.length;i++)&#123;</span><br><span class="line">  sum+=menu[i].size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>

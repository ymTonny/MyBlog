<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>代码评审清单</title>
    <url>/2018/12/12/CodecheckList/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="前端团队根据情况有时候会有评审代码的要求，但是由于每个开发人员的技术水平不同，代码风格不同，所关注的技术点也不同，为了保证代码的质量以及团队的代码风格统一，因此产生了团队中的CodeReview-为此拟了一份清单-如果你的团队还没有CodeReview，可能这正是你需要的。"><a href="#前端团队根据情况有时候会有评审代码的要求，但是由于每个开发人员的技术水平不同，代码风格不同，所关注的技术点也不同，为了保证代码的质量以及团队的代码风格统一，因此产生了团队中的CodeReview-为此拟了一份清单-如果你的团队还没有CodeReview，可能这正是你需要的。" class="headerlink" title="前端团队根据情况有时候会有评审代码的要求，但是由于每个开发人员的技术水平不同，代码风格不同，所关注的技术点也不同，为了保证代码的质量以及团队的代码风格统一，因此产生了团队中的CodeReview,为此拟了一份清单,如果你的团队还没有CodeReview，可能这正是你需要的。"></a>前端团队根据情况有时候会有评审代码的要求，但是由于每个开发人员的技术水平不同，代码风格不同，所关注的技术点也不同，为了保证代码的质量以及团队的代码风格统一，因此产生了团队中的CodeReview,为此拟了一份清单,如果你的团队还没有CodeReview，可能这正是你需要的。</h4><h2 id="一、代码静态检查工具"><a href="#一、代码静态检查工具" class="headerlink" title="一、代码静态检查工具"></a>一、代码静态检查工具</h2><h3 id="1-1、使用eslint工具对javascript代码进行检查。"><a href="#1-1、使用eslint工具对javascript代码进行检查。" class="headerlink" title="1.1、使用eslint工具对javascript代码进行检查。"></a>1.1、使用eslint工具对javascript代码进行检查。</h3><p><code>eslint</code>检查的规范继承自<code>eslint-config-standard</code>检验规则。<br><a id="more"></a></p>
<h3 id="1-2、使用stylelint工具对css样式代码进行检查。"><a href="#1-2、使用stylelint工具对css样式代码进行检查。" class="headerlink" title="1.2、使用stylelint工具对css样式代码进行检查。"></a>1.2、使用stylelint工具对css样式代码进行检查。</h3><p><code>stylelint</code>检查的规范继承自<code>stylelint-config-standard</code>检验规则。</p>
<h2 id="二、命名规范"><a href="#二、命名规范" class="headerlink" title="二、命名规范"></a>二、命名规范</h2><h3 id="2-1、JS采用Camel-Case小驼峰命名"><a href="#2-1、JS采用Camel-Case小驼峰命名" class="headerlink" title="2.1、JS采用Camel Case小驼峰命名"></a>2.1、JS采用Camel Case小驼峰命名</h3><p>推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">studentInfo</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2、避免名称冗余"><a href="#2-2、避免名称冗余" class="headerlink" title="2.2、避免名称冗余"></a>2.2、避免名称冗余</h3><p>推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Car = &#123;</span><br><span class="line">  money:123,</span><br><span class="line">  color:&quot;red&quot;,</span><br><span class="line">  name:&quot;大地&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Car = &#123;</span><br><span class="line">  Carmoney:123,</span><br><span class="line">  Carcolor:&quot;red&quot;,</span><br><span class="line">  Carname:&quot;大地&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3、CSS类名采用BEM命名规范"><a href="#2-3、CSS类名采用BEM命名规范" class="headerlink" title="2.3、CSS类名采用BEM命名规范"></a>2.3、CSS类名采用BEM命名规范</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.block_element&#123;&#125;     // 代表块block元素中的子元素element</span><br><span class="line">.block--modifier&#123;&#125;  //  代表块block元素的状态</span><br></pre></td></tr></table></figure>
<h3 id="2-4、命名符合语义化"><a href="#2-4、命名符合语义化" class="headerlink" title="2.4、命名符合语义化"></a>2.4、命名符合语义化</h3><p>命名需要符合语义化，如果是函数命名可以采用加上动词前缀<br>动词      含义<br>can       判断是否可以执行某个动作<br>has       判断是否含有某一个值<br>is          判断是否为某一个值<br>get        获取某一个值<br>set        设置某一个值<br>推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 是否显示</span><br><span class="line">function canShow()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 设置名称</span><br><span class="line">function setName()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、JS推荐写法"><a href="#三、JS推荐写法" class="headerlink" title="三、JS推荐写法"></a>三、JS推荐写法</h2><h3 id="3-1、每个常量都需要命名"><a href="#3-1、每个常量都需要命名" class="headerlink" title="3.1、每个常量都需要命名"></a>3.1、每个常量都需要命名</h3><p>每个常量应该命名，不然看代码的人不知道这个常量的意思。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const COL_NUM = 10</span><br><span class="line">let row = Math.ceil(num/COL_NUM)</span><br></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let row = Math.ceil(num/10)</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2、推荐使用字面量"><a href="#3-2、推荐使用字面量" class="headerlink" title="3.2、推荐使用字面量"></a>3.2、推荐使用字面量</h3><p>创建对象和数组推荐使用字面量，因为这不仅是性能最优也有助于节省代码量。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">   name:&quot;tonny&quot;,</span><br><span class="line">   age:12,</span><br><span class="line">   sex:&quot;男&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">obj.name = &quot;tonny&quot;</span><br><span class="line">obj.age = 12</span><br><span class="line">obj.sex = &quot;男&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3、-函数参数"><a href="#3-3、-函数参数" class="headerlink" title="3.3、 函数参数"></a>3.3、 函数参数</h3><p>函数参数越少越好，如果参数超过两个，要使用 ES6的解构语法，不用考虑参数的顺序。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createMenu(&#123;title,name,value,label&#125;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">createMenu(&#123;</span><br><span class="line">  title:&quot;ad&quot;,</span><br><span class="line">  name:&quot;tonny&quot;,</span><br><span class="line">  value:&quot;123&quot;,</span><br><span class="line">  label:&quot;button&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createMenu(title,name,value,label)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-4、使用参数默认值，代替使用条件语句进行赋值"><a href="#3-4、使用参数默认值，代替使用条件语句进行赋值" class="headerlink" title="3.4、使用参数默认值，代替使用条件语句进行赋值"></a>3.4、使用参数默认值，代替使用条件语句进行赋值</h3><p>推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function create(name=&quot;abc&quot;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function create(name)&#123;</span><br><span class="line">  let newName = name || &quot;abc&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-5、推荐使用函数式编程"><a href="#3-5、推荐使用函数式编程" class="headerlink" title="3.5、推荐使用函数式编程"></a>3.5、推荐使用函数式编程</h3><p>函数式编程可以让代码的逻辑更清晰更优雅，方便测试<br>推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const menu = [</span><br><span class="line"> &#123;name:&quot;a&quot;,size:1&#125;,</span><br><span class="line"> &#123;name:&quot;b&quot;,size:2&#125;,</span><br><span class="line"> &#123;name:&quot;c&quot;,size:3&#125;</span><br><span class="line">]</span><br><span class="line">let sumMenu = menu.map(item =&gt; item.size).reduce((prevsize,nextsize)=&gt; previse+nextsize,0);</span><br></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sum = 0;</span><br><span class="line">for(let i=0;i&lt;menu.length;i++)&#123;</span><br><span class="line">  sum+=menu[i].size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>async-await</title>
    <url>/2019/08/02/async-await/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>   <code>Asyns-Await</code>,异步编程的最高境界，就是根本不用担心它异步。<code>async</code>函数就是隧道尽头的亮光，大部分人会认为它是异步操作的终极解决方案。<code>async-await</code>和<code>promise</code>的关系，两者不存在谁代替谁，因为<code>async-await</code>寄生于<code>Promise</code>.<code>Generator</code>的语法糖。<code>async</code>和<code>await</code>在干什么？<code>async</code>用于申明一个<code>function</code>函数是异步的，而<code>await</code>可以认为是<code>async await</code>的简写，等待一个异步函数执行完成。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function demo(params)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">//async 函数返回的是一个Promise对象</span><br><span class="line">demo();</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ul>
<li>async表示这是一个async函数，await只能用在这个函数里面。</li>
<li>await表示这里等待promise返回结果后，再继续执行。</li>
<li>await后面应该跟着一个promise对象（普通函数亦可，但await就无意义了）。</li>
<li>await不能单独使用，必须搭配aync函数来使用。</li>
<li>await等待的虽然是一个promise对象，但是不必写.then(…),直接可以得到返回值。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function demo(params)&#123;</span><br><span class="line">   let result = await Promise.resolve(123);</span><br><span class="line">   console.log(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="捕捉错误"><a href="#捕捉错误" class="headerlink" title="捕捉错误"></a>捕捉错误</h2><p>像<code>Promise</code>有<code>.then(...),.catch(...)</code>来捕捉正确与错误，而<code>async</code>这两个都不用写，那么我们就可以直接用标准的<code>try catch</code>语法捕捉错误。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sleep = function (time) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            // 模拟出错了，返回 ‘error’</span><br><span class="line">            reject(&apos;error&apos;);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let start = async function () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        console.log(&apos;start&apos;);</span><br><span class="line">        await sleep(3000); // 这里得到了一个返回错误</span><br><span class="line">        </span><br><span class="line">        // 所以以下代码不会被执行了</span><br><span class="line">        console.log(&apos;end&apos;);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        console.log(err); // 这里捕捉到错误 `error`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="循环多个await"><a href="#循环多个await" class="headerlink" title="循环多个await"></a>循环多个await</h2><p><code>await</code>看起来像是同步代码,所以写在for循环内，不必担心需要闭包才能解决。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">..省略以上代码</span><br><span class="line"></span><br><span class="line">let start = async function () &#123;</span><br><span class="line">    for (let i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">        console.log(`当前是第$&#123;i&#125;次等待..`);</span><br><span class="line">        await sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组去重多一种选择</title>
    <url>/2019/08/11/array/</url>
    <content><![CDATA[<p>数组去重，一般在面试的时候都会被问到，要求现场写去重代码，那么你知道有多少去重的方法呢？如果你能答出多种的话，面试官一定会对你刮目相看的。</p>
<p>数组去重的方法：</p>
<h2 id="一、利用ES6-Set去重"><a href="#一、利用ES6-Set去重" class="headerlink" title="一、利用ES6 Set去重"></a>一、利用ES6 Set去重</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr)&#123;</span><br><span class="line">  return Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br><span class="line">let arr = [1,1,2,2,3,3];</span><br><span class="line">console.log(uniq(arr));</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果不考虑兼容性的话，此方法代码最少。</p>
<h2 id="二、利用splice去重。"><a href="#二、利用splice去重。" class="headerlink" title="二、利用splice去重。"></a>二、利用splice去重。</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr)&#123;</span><br><span class="line">  if(!Array.isArray(arr))&#123;</span><br><span class="line">     console.log(&quot;no array&quot;);</span><br><span class="line">     return</span><br><span class="line">  &#125;</span><br><span class="line">  for(let i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    for(let j=i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">       if(arr[i]==arr[j])&#123;</span><br><span class="line">         arr.splice(j,1);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br><span class="line">let arr=[1,1,2,2,3,3];</span><br><span class="line">console.log(uniq(arr));</span><br></pre></td></tr></table></figure>
<p>双重for循环，外层循环元素，内层判断值，值相等就通过<code>splice</code>删除。</p>
<h2 id="三、利用indexOf去重"><a href="#三、利用indexOf去重" class="headerlink" title="三、利用indexOf去重"></a>三、利用indexOf去重</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr)&#123;</span><br><span class="line">  if(!Array.isArray(arr))&#123;</span><br><span class="line">     console.log(&quot;no array&quot;);</span><br><span class="line">     return</span><br><span class="line">  &#125;</span><br><span class="line">  let array=[];</span><br><span class="line">  for(let i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">     if(array.indexOf(arr[i])==-1)&#123;</span><br><span class="line">       array.push(arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return array;</span><br><span class="line">&#125;</span><br><span class="line">let arr=[1,1,2,2,3,3];</span><br><span class="line">console.log(uniq(arr))</span><br></pre></td></tr></table></figure>
<p>通过新建一个空数组，for循环判断空数组中是否存在当前元素，如果不存在就<code>push</code>进去，如果存在就跳过。</p>
<h2 id="四、利用sort"><a href="#四、利用sort" class="headerlink" title="四、利用sort()"></a>四、利用sort()</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr)&#123;</span><br><span class="line"> if(!Array.isArray(arr))&#123;</span><br><span class="line">   console.log(&quot;no array&quot;);</span><br><span class="line">   return</span><br><span class="line"> &#125;</span><br><span class="line"> arr = arr.sort();</span><br><span class="line"> let array = [];</span><br><span class="line"> for(let i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">   if(arr[i]!=arr[i+1])&#123;</span><br><span class="line">     array.push(arr[i]);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return array;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [1,2,3,6,4,2,1];</span><br><span class="line">console.log(uniq(arr))</span><br></pre></td></tr></table></figure>
<p>通过<code>sort()</code>排序过后，再用for循环遍历比较相邻元素。</p>
<h2 id="五、利用对象的属性不能相同去重"><a href="#五、利用对象的属性不能相同去重" class="headerlink" title="五、利用对象的属性不能相同去重"></a>五、利用对象的属性不能相同去重</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr)&#123;</span><br><span class="line">  if(!Array.isArray(arr))&#123;</span><br><span class="line">    console.log(&quot;no array&quot;);</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  let array=[],obj=&#123;&#125;;</span><br><span class="line">  for(let i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(!obj[arr[i]])&#123;</span><br><span class="line">      array.push(arr[i]);</span><br><span class="line">      obj[arr[i]]=1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      obj[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return array;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [1,2,3,4,2,3,1];</span><br><span class="line">console.log(uniq(arr))</span><br></pre></td></tr></table></figure>
<h2 id="六、利用includes"><a href="#六、利用includes" class="headerlink" title="六、利用includes"></a>六、利用includes</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr)&#123;</span><br><span class="line"> if(!Array.isArray(arr))&#123;</span><br><span class="line">   console.log(&quot;no array&quot;);</span><br><span class="line">   return;</span><br><span class="line"> &#125;</span><br><span class="line"> let array = [];</span><br><span class="line"> for(let i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">   if(!array.includes(arr[i]))&#123; //array中是否存在arr[i]元素</span><br><span class="line">     array.push(arr[i]);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return array;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [1,2,3,5,2,1];</span><br><span class="line">console.log(uniq(arr));</span><br></pre></td></tr></table></figure>
<h2 id="七、利用hasOwnProperty"><a href="#七、利用hasOwnProperty" class="headerlink" title="七、利用hasOwnProperty"></a>七、利用hasOwnProperty</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr)&#123;</span><br><span class="line"> let obj = &#123;&#125;;</span><br><span class="line"> return arr.filter((item,index,arr)=&gt;&#123;</span><br><span class="line">   return obj.hasOwnProperty(typeof item+item) ? false:(obj[typeof item+item]=true)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">let arr = [1,2,3,5,2,1];</span><br><span class="line">console.log(uniq(arr));</span><br></pre></td></tr></table></figure>
<h2 id="八、利用filter"><a href="#八、利用filter" class="headerlink" title="八、利用filter"></a>八、利用filter</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr)&#123;</span><br><span class="line"> return arr.filter((item,index,arr)=&gt;&#123;</span><br><span class="line">   //当前元素，在原数组中的第一个索引 === 当前索引值,否则返回当前元素</span><br><span class="line">   return arr.indexOf(item,0) === index;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">let arr = [1,2,3,5,2,1];</span><br><span class="line">console.log(uniq(arr));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转clip-path</title>
    <url>/2019/07/23/clip-path/</url>
    <content><![CDATA[<h1 id="一-基本概念"><a href="#一-基本概念" class="headerlink" title="一.基本概念"></a>一.基本概念</h1><p>什么是<code>clip-path</code>呢？简而言之就是实现裁剪的<code>css</code>属性,我们可以通过该属性创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的部分隐藏。通过指定路径就可以创建出自己想要的形状，这样网页中的布局就可以是多种多样的了。</p>
<p>在<code>clip-path</code>出现之前，css还有个属性<code>clip</code>也支持裁剪，但是它只支持矩形裁剪,同时它只对<code>position:absolute</code>和<code>position:fixed</code>的元素生效。使用如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clip: rect(50px,50px,50px,50px) //标准写法</span><br><span class="line">clip: rect(50px 50px 50px 50px) //兼容浏览器写法</span><br></pre></td></tr></table></figure></p>
<p>目前所有主流浏览器都支持<code>clip</code>,但是因为其局限性,<code>clip</code>已经被<code>clip-path</code>代替。<code>clip-path</code>为我们带来了更多的可能，让我们制作出更多有趣的图案。<br><a id="more"></a></p>
<h1 id="二-用法实例"><a href="#二-用法实例" class="headerlink" title="二.用法实例"></a>二.用法实例</h1><h2 id="1-基本图形：inset"><a href="#1-基本图形：inset" class="headerlink" title="1.基本图形：inset"></a>1.基本图形：inset</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inset()//定义一个矩形,注意:此处矩形不是 rect 而是 inset.</span><br><span class="line">//语法</span><br><span class="line">inset()可以传入5个参数，分别对应top,right,bottom,left的裁剪位置,和round radius（可选项 圆角）。</span><br><span class="line"></span><br><span class="line">//示例</span><br><span class="line">clip-path:inset(15% 20% 15% 20%)</span><br></pre></td></tr></table></figure>
 <div style="width:200px;height:200px;margin:auto"><img src="https://s2.ax1x.com/2019/03/27/Aa7B0s.png" alt="avatart"></div>

<h2 id="2-基本图形：circle"><a href="#2-基本图形：circle" class="headerlink" title="2.基本图形：circle"></a>2.基本图形：circle</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">circle()//定义一个圆形</span><br><span class="line">//语法</span><br><span class="line">circle()//可以传入2个参数，用at分开,分别对应圆的半径,圆心位置。圆心默认为元素中心点。</span><br><span class="line">//示例</span><br><span class="line">clip-path:circle(50% at 50% 50%)</span><br></pre></td></tr></table></figure>
 <div style="width:200px;height:200px;margin:auto"><img src="https://ws2.sinaimg.cn/mw690/005SNrnIgy1g1hef0awp6j308r08gq6d.jpg" alt="avatart"></div>

<h2 id="3-基本图形：ellipse"><a href="#3-基本图形：ellipse" class="headerlink" title="3.基本图形：ellipse"></a>3.基本图形：ellipse</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ellipse()//定义一个椭圆</span><br><span class="line">//语法</span><br><span class="line">ellipse(x y at positon)//x为椭圆的x轴半径,y为椭圆的y轴半径,position为椭圆中心位置。</span><br><span class="line">//示例</span><br><span class="line">clip-path:ellipse(25% 40% at 50% 50%)</span><br></pre></td></tr></table></figure>
<p> <div style="width:200px;height:200px;margin:auto"><img src="https://ws2.sinaimg.cn/mw690/005SNrnIgy1g1hekwf3c2j308i089myl.jpg" alt="avatart"></div></p>
<h2 id="4-基本图形：polygon"><a href="#4-基本图形：polygon" class="headerlink" title="4.基本图形：polygon"></a>4.基本图形：polygon</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plygon()//定义一个多边形</span><br><span class="line">//语法</span><br><span class="line">polygon(fill-rule,[x y])//fill-rule(可选)表示填充规则用来确定该多边形内部,值有nonzero 和evenodd，默认为evenodd。后面的每一对表示连接点的坐标。</span><br><span class="line">//示例</span><br><span class="line">clip-path: polygon(50% 0%, 0 100%, 100% 100%);</span><br><span class="line">clip-path: polygon(20% 0%, 0% 20%, 30% 50%, 0% 80%, 20% 100%, 50% 70%, 80% 100%, 100% 80%, 70% 50%, 100% 20%, 80% 0%, 50% 30%);</span><br></pre></td></tr></table></figure>
<p> <div style="display:flex;justify-content:space-around;"><img src="https://ws2.sinaimg.cn/mw690/005SNrnIgy1g1hez6l3rej309208sdi4.jpg" alt="avatart"><br> <img src="https://ws4.sinaimg.cn/mw690/005SNrnIgy1g1hf2dedn8j308x08q0vd.jpg" alt="avatart"><br> </div></p>
<h2 id="5-其他属性"><a href="#5-其他属性" class="headerlink" title="5.其他属性"></a>5.其他属性</h2><p>除了<code>inset</code>，<code>circle</code>，<code>ellipse</code>，<code>polygon</code>属性外，<code>clip-path</code>还具有<code>url</code>，<code>geometry-box</code>等属性值，具体可以参考<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path" target="_blank">MDN</a></p>
<h1 id="三-兼容性"><a href="#三-兼容性" class="headerlink" title="三.兼容性"></a>三.兼容性</h1><p><img src="https://wx4.sinaimg.cn/large/005SNrnIgy1g1hfchdbflj30z5073gm1.jpg" alt="avatart"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>electron打包react项目</title>
    <url>/2019/06/13/electron-packager/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>懂的小伙伴大概已经知道这是个什么了，那么不懂的小伙伴听我大致道来。也许你不甘心只写网页，也想写一个电脑上的exe程序那种；或者你有项目需求必须要写个exe程序，但是你只会前端，没关系，看了这篇文章你也就能写出一个exe程序了。<br><a id="more"></a></p>
<h2 id="一、安装electron"><a href="#一、安装electron" class="headerlink" title="一、安装electron"></a>一、安装electron</h2><ul>
<li>为了方便以后使用，建议进行全局安装，这样任何文件夹下面就都能使用<code>electron</code>了。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//安装命令</span><br><span class="line">npm install electron  --g</span><br><span class="line">//npm如果太慢的话，我们就改用国内镜像，国内镜像安装如下:</span><br><span class="line">npm install cnpm -g  --registry=https://registry.npm.taobao.org</span><br><span class="line">cnpm install electron --save</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、react使用electron"><a href="#二、react使用electron" class="headerlink" title="二、react使用electron"></a>二、react使用electron</h2><h3 id="添加electron包"><a href="#添加electron包" class="headerlink" title="添加electron包"></a>添加electron包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install electron --save</span><br><span class="line">//安装打包工具</span><br><span class="line">npm install electron-packager --save-dev</span><br></pre></td></tr></table></figure>
<h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><h4 id="配置main-js"><a href="#配置main-js" class="headerlink" title="配置main.js"></a>配置main.js</h4><p>在项目根目录(不是src目录)下新建一个main.js，写入如下配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//引入electron并创建一个BrowserWindow</span><br><span class="line">const &#123;app,BrowserWindow&#125; = require(&quot;electron&quot;);</span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">const url = require(&quot;path&quot;);</span><br><span class="line">//保持window对象的全局引用，避免Javascript对象被垃圾回收时，窗口被自动关闭</span><br><span class="line">let win;</span><br><span class="line"></span><br><span class="line">function createWindow()&#123;</span><br><span class="line"> //创建浏览器窗口，宽高随意</span><br><span class="line">  win = new BrowserWindow(&#123;width:800,height:600&#125;);</span><br><span class="line"> </span><br><span class="line"> //加载应用----  适用桌面应用</span><br><span class="line"> /*win.loadURL(url.format(&#123;</span><br><span class="line">   pathname:path.join(_dirname+&quot;./build/index.html&quot;),</span><br><span class="line">   protocol:&quot;file:&quot;</span><br><span class="line">   slashes:true</span><br><span class="line"> &#125;))*/</span><br><span class="line"> // 加载应用---- 适用react</span><br><span class="line"> win.loadURL(&quot;http://localhost:3000/&quot;);</span><br><span class="line"> //打开开发者工具,默认不打开</span><br><span class="line"> win.webContents.openDevTools();</span><br><span class="line"> </span><br><span class="line"> //关闭window时触发</span><br><span class="line"> win.on(&quot;closed&quot;,function()&#123;</span><br><span class="line">   win = null</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//当electron初始化完成后并开始创建浏览器窗口时运行</span><br><span class="line">app.on(&quot;ready&quot;,createWindow);</span><br><span class="line"></span><br><span class="line">//所有窗口关闭时，退出应用</span><br><span class="line">app.on(&quot;window-all-closed&quot;,function(&#123;</span><br><span class="line">// macOS中除非用户按下 `Cmd + Q` 显式退出,否则应用与菜单栏始终处于活动状态.</span><br><span class="line">  if (process.platform !== &apos;darwin&apos;) &#123;</span><br><span class="line">    app.quit()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.on(&apos;activate&apos;, function () &#123;</span><br><span class="line">   // macOS中点击Dock图标时没有已打开的其余应用窗口时,则通常在应用中重建一个窗口</span><br><span class="line">  if (win === null) &#123;</span><br><span class="line">    createWindow()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="配置package-json"><a href="#配置package-json" class="headerlink" title="配置package.json"></a>配置package.json</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;platform&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;This is a food and beverage management system&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;main.js&quot;, //配置electron启动文件</span><br><span class="line">  &quot;homepage&quot;: &quot;.&quot;, //配置electron打包后静态static不能访问</span><br><span class="line">  &quot;DEV&quot;:false,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;babel-node devServer.js --progress --colors&quot;,</span><br><span class="line">    &quot;dist&quot;: &quot;webpack --config webpack.config.pro.js --progress --colors &quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack --progress&quot;,</span><br><span class="line">    &quot;electron-start&quot;: &quot;electron .&quot;, //配置运行桌面应用指令</span><br><span class="line">    //配置打包为桌面应用指令</span><br><span class="line">    &quot;packager&quot;: &quot;electron-packager ./ react-electron --win --out ~/ --electron-version 1.7.10&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;babel-node devServer.js --progress --colors ./node_modules/.bin/electron ./main&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h3 id="开始打包"><a href="#开始打包" class="headerlink" title="开始打包"></a>开始打包</h3><p>在项目根目录运行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run packager</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>el-cascader组件扩展</title>
    <url>/2022/04/27/el-cascader/</url>
    <content><![CDATA[<p>在<code>Vue</code>中使用<code>ElementUI</code>的级联选择省市区组件时，会出现一些不同需求及该组件内部一些bug的问题，以下列举部分问题</p>
<h2 id="1-同级多选、一条链路单选"><a href="#1-同级多选、一条链路单选" class="headerlink" title="1.同级多选、一条链路单选"></a>1.同级多选、一条链路单选</h2><p>链路单选：[‘北京’, ‘北京市’, ‘北京市/东城区’]类似这样一条链路只能单选存在其一<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-cascader ref=&quot;cascader&quot; /&gt;</span><br><span class="line">change事件时重设value</span><br><span class="line">rewriteSetValue() &#123;</span><br><span class="line">  const result = [];</span><br><span class="line">  const paths = [];</span><br><span class="line">  const checkedNodes = this.$refs.cascader.getCheckedNodes();</span><br><span class="line">  // 获取当前点击checked</span><br><span class="line">  const focusDOM = document.getElementsByClassName(&quot;el-checkbox__input is-focus&quot;)[0]</span><br><span class="line">  if (!focusDOM) return;</span><br><span class="line">  const curName = focusDOM.parentElement.nextElementSibling.innerHTML;</span><br><span class="line">  const curData = checkedNodes.find(v=&gt;v.label===curName);</span><br><span class="line"></span><br><span class="line">  if (!curData) return;</span><br><span class="line">  this.setTreeCheckedValue(curData);</span><br><span class="line"></span><br><span class="line">  this.value.forEach(node =&gt; &#123;</span><br><span class="line">    let id = node[node.length - 1];</span><br><span class="line">    let nodes = this.$refs.cascader.$children[1].getNodeByValue(id);</span><br><span class="line">    if (nodes.checked) &#123;</span><br><span class="line">      result.push(node);</span><br><span class="line">      paths.push(curData);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  this.$refs.cascader.$children[1].checkedNodePaths = paths;</span><br><span class="line">  this.$refs.cascader.$children[1].checkedValue = result;</span><br><span class="line">  this.value = result;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h2 id="2-多选lazyLoad模式change值问题"><a href="#2-多选lazyLoad模式change值问题" class="headerlink" title="2.多选lazyLoad模式change值问题"></a>2.多选lazyLoad模式change值问题</h2><p>当选中父节点通过<code>lazyLoad</code>加载子节点时，会触发<code>change</code>事件，传入的值不包含当前选中的子节点。可通过在lazyLoad模式的方法中设置一个状态阻止<code>change</code>之后的操作<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">  lazy: true,</span><br><span class="line">  lazyLoad: loadCity</span><br><span class="line">&#125;</span><br><span class="line">loadCity(node, resolve) &#123;</span><br><span class="line">  if (node.level !== 0 &amp;&amp; node.checked) this.mulLazyChangeFlag = false;</span><br><span class="line">&#125;</span><br><span class="line">change() &#123;</span><br><span class="line">  if (this.multiple &amp;&amp; !this.mulLazyChangeFlag) &#123;</span><br><span class="line">    this.mulLazyChangeFlag = true;</span><br><span class="line">    return;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-多选模式下，删除tag时触发change会传回上一次数据"><a href="#3-多选模式下，删除tag时触发change会传回上一次数据" class="headerlink" title="3.多选模式下，删除tag时触发change会传回上一次数据"></a>3.多选模式下，删除tag时触发change会传回上一次数据</h2><p>通过<code>$nextTick</code>来包装<code>change</code>事件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$nextTick(() =&gt; this.$emit(&apos;change&apos;))</span><br></pre></td></tr></table></figure></p>
<h2 id="4-多选折叠模式控制展示数量"><a href="#4-多选折叠模式控制展示数量" class="headerlink" title="4.多选折叠模式控制展示数量"></a>4.多选折叠模式控制展示数量</h2><p>可通过重写tags方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-cascader ref=&quot;cascader&quot;&gt;</span><br><span class="line"></span><br><span class="line">mounted() &#123;</span><br><span class="line">  this.$refs.cascader.computePresentTags = this.rewriteComputedTags;</span><br><span class="line">&#125;</span><br><span class="line">rewriteComputedTags() &#123;</span><br><span class="line">  const _this = this.$refs.cascader;</span><br><span class="line">  const &#123; isDisabled, leafOnly, showAllLevels, separator &#125; = _this;</span><br><span class="line">  const checkedNodes = _this.getCheckedNodes(leafOnly);</span><br><span class="line">  const tags = [];</span><br><span class="line"></span><br><span class="line">  const genTag = node =&gt; (&#123;</span><br><span class="line">    node,</span><br><span class="line">    key: node.uid,</span><br><span class="line">    text: node.getText(showAllLevels, separator),</span><br><span class="line">    hitState: false,</span><br><span class="line">    closable: !isDisabled &amp;&amp; !node.isDisabled,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  if (checkedNodes.length) tags.push(...this.formatComputedTags(checkedNodes, genTag));</span><br><span class="line"></span><br><span class="line">  _this.checkedNodes = checkedNodes;</span><br><span class="line">  _this.presentTags = tags;</span><br><span class="line">&#125;,</span><br><span class="line">formatComputedTags(tagsList, callback) &#123;</span><br><span class="line">  const tags = [];</span><br><span class="line">  if (this.collapseTags) &#123;</span><br><span class="line">    tagsList.forEach((node, index) =&gt; &#123;</span><br><span class="line">      if (index &lt; this.tagsNum) &#123;</span><br><span class="line">        tags.push(callback ? callback(node) : node)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    if (tagsList.length &gt; this.tagsNum) &#123;  // tagsNum：控制折叠下展示的tag数量</span><br><span class="line">      tags.push(&#123;</span><br><span class="line">        key: -1,</span><br><span class="line">        text: `+ $&#123;tagsList.length - this.tagsNum&#125;`,</span><br><span class="line">        closable: false,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return tags;</span><br><span class="line">  &#125;</span><br><span class="line">  tagsList.forEach(node =&gt; tags.push(callback ? callback(node) : node));</span><br><span class="line">  return tags;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题 --vue</title>
    <url>/2019/06/20/interview/</url>
    <content><![CDATA[<h3 id="1-说一下Vue的双向绑定数据的原理"><a href="#1-说一下Vue的双向绑定数据的原理" class="headerlink" title="1. 说一下Vue的双向绑定数据的原理"></a>1. 说一下Vue的双向绑定数据的原理</h3><p><code>vue</code> 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 <code>Object.defineProperty()</code> 来劫持各个属性的 <code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应监听回调</p>
<a id="more"></a>
<h3 id="2-解释单向数据流和双向数据绑定"><a href="#2-解释单向数据流和双向数据绑定" class="headerlink" title="2. 解释单向数据流和双向数据绑定"></a>2. 解释单向数据流和双向数据绑定</h3><p> 单向数据流： 顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使UI发生变更就必须创建各种 <code>action</code> 来维护对应的 <code>state</code></p>
<p> 双向数据绑定：数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时 <code>debug</code> 的难度</p>
<h3 id="3-Vue-如何去除url中的"><a href="#3-Vue-如何去除url中的" class="headerlink" title="3. Vue 如何去除url中的 #"></a>3. Vue 如何去除url中的 <code>#</code></h3><p><code>vue-router</code> 默认使用 <code>hash</code> 模式，所以在路由加载的时候，项目中的 <code>url</code> 会自带 <code>#</code>。如果不想使用 <code>#</code>， 可以使用 <code>vue-router</code> 的另一种模式 <code>history</code><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">new Router(&#123;</span><br><span class="line">      mode: <span class="string">'history'</span>,</span><br><span class="line">      routes: [ ]</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，当我们启用 <code>history</code>模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现<code>404</code>的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 <code>URL</code> 匹配不到任何静态资源，则应该返回同一个 <code>index.html</code> 页面</p>
<h3 id="4-vue生命周期理解"><a href="#4-vue生命周期理解" class="headerlink" title="4.vue生命周期理解"></a>4.vue生命周期理解</h3><p>vue实例有一个完整的生命周期，生命周期也就是指一个实例从开始创建到销毁的这个过程</p>
<ul>
<li><code>beforeCreated()</code> 在实例创建之间执行，数据未加载状态 <code>created()</code></li>
<li>在实例创建、数据加载后，能初始化数据，dom渲染之前执行 </li>
<li><code>beforeMount()</code> 虚拟<code>dom</code>已创建完成，在数据渲染前最后一次更改数据</li>
<li><code>mounted()</code> 页面、数据渲染完成，真实dom挂载完成 </li>
<li><code>beforeUpadate()</code> 重新渲染之前触发 <code>updated()</code></li>
<li>数据已经更改完成，<code>dom</code> 也重新 <code>render</code> 完成,更改数据会陷入死循环 </li>
<li><code>beforeDestory()</code> 和 <code>destoryed()</code>前者是销毁前执行（实例仍然完全可用），后者则是销毁后执行</li>
</ul>
<h3 id="5-v-if和v-show区别"><a href="#5-v-if和v-show区别" class="headerlink" title="5.v-if和v-show区别"></a>5.v-if和v-show区别</h3><p> 使用了 <code>v-if</code> 的时候，如果值为 <code>false</code> ，那么页面将不会有这个 <code>html</code> 标签生成。</p>
<p> <code>v-show</code> 则是不管值为 <code>true</code> 还是 <code>false</code> ，<code>html</code> 元素都会存在，只是 <code>CSS</code> 中的 <code>display</code> 显示或隐藏</p>
<h3 id="6-route和-router的区别"><a href="#6-route和-router的区别" class="headerlink" title="6. $route和$router的区别"></a>6. <code>$route</code>和<code>$router</code>的区别</h3><p> <code>$router</code> 为 <code>VueRouter</code> 实例，想要导航到不同 <code>URL</code>，则使用 <code>$router.push</code> 方法</p>
<p> <code>$route</code> 为当前 <code>router</code> 跳转对象里面可以获取 <code>name</code> 、 <code>path</code> 、 <code>query</code> 、 <code>params</code> 等</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用操作</title>
    <url>/2019/07/02/git-operating/</url>
    <content><![CDATA[<h1 id="一-ssh-key生成"><a href="#一-ssh-key生成" class="headerlink" title="一.ssh key生成"></a>一.ssh key生成</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;email&quot;</span><br></pre></td></tr></table></figure>
<h1 id="二-clone-项目"><a href="#二-clone-项目" class="headerlink" title="二.clone 项目"></a>二.clone 项目</h1><p>clone git上的项目,如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:ymtonny/myBlog.git</span><br></pre></td></tr></table></figure></p>
<h1 id="三-管理分支"><a href="#三-管理分支" class="headerlink" title="三.管理分支"></a>三.管理分支</h1><h2 id="1-查看分支"><a href="#1-查看分支" class="headerlink" title="1.查看分支"></a>1.查看分支</h2><a id="more"></a>
<h3 id="1-1-查看本地分支"><a href="#1-1-查看本地分支" class="headerlink" title="1.1.查看本地分支"></a>1.1.查看本地分支</h3><p>使用git branch命令,如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch </span><br><span class="line">* master</span><br></pre></td></tr></table></figure></p>
<p>*标识的是你当前所在的分支</p>
<h3 id="1-2-查看远程分支"><a href="#1-2-查看远程分支" class="headerlink" title="1.2.查看远程分支"></a>1.2.查看远程分支</h3><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3-查看所有分支"><a href="#1-3-查看所有分支" class="headerlink" title="1.3.查看所有分支"></a>1.3.查看所有分支</h3><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure></p>
<h2 id="2-本地创建新分支"><a href="#2-本地创建新分支" class="headerlink" title="2.本地创建新分支"></a>2.本地创建新分支</h2><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch [branch name]</span><br></pre></td></tr></table></figure></p>
<h2 id="3-切换到新分支"><a href="#3-切换到新分支" class="headerlink" title="3.切换到新分支"></a>3.切换到新分支</h2><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout [branch name]</span><br></pre></td></tr></table></figure></p>
<h2 id="4-创建-切换分支"><a href="#4-创建-切换分支" class="headerlink" title="4.创建+切换分支"></a>4.创建+切换分支</h2><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b [branch name]</span><br></pre></td></tr></table></figure></p>
<h2 id="5-将新分支上传到远程分支中"><a href="#5-将新分支上传到远程分支中" class="headerlink" title="5.将新分支上传到远程分支中"></a>5.将新分支上传到远程分支中</h2><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin [branch name]</span><br></pre></td></tr></table></figure></p>
<h2 id="6-删除本地分支"><a href="#6-删除本地分支" class="headerlink" title="6.删除本地分支"></a>6.删除本地分支</h2><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d [branch name]</span><br></pre></td></tr></table></figure></p>
<h2 id="7-删除远程分支"><a href="#7-删除远程分支" class="headerlink" title="7.删除远程分支"></a>7.删除远程分支</h2><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin :[branch name]</span><br></pre></td></tr></table></figure></p>
<p>分支名前冒号代表删除。</p>
<h2 id="8-一次删除本地存在的远程没有的分支"><a href="#8-一次删除本地存在的远程没有的分支" class="headerlink" title="8.一次删除本地存在的远程没有的分支"></a>8.一次删除本地存在的远程没有的分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote show origin</span><br><span class="line">git remote prune</span><br></pre></td></tr></table></figure>
<h2 id="9-本地文件夹关联远程仓库"><a href="#9-本地文件夹关联远程仓库" class="headerlink" title="9.本地文件夹关联远程仓库"></a>9.本地文件夹关联远程仓库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin [仓库git链接]</span><br><span class="line">//推送代码</span><br><span class="line">git push -u origin master //-u 使其与远程关联 简化后期推送操作</span><br></pre></td></tr></table></figure>
<h2 id="10-撤销add-commit-修改commit信息"><a href="#10-撤销add-commit-修改commit信息" class="headerlink" title="10.撤销add, commit, 修改commit信息"></a>10.撤销add, commit, 修改commit信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//撤销add</span><br><span class="line">git reset</span><br><span class="line">//撤销commit</span><br><span class="line">git reset HEAD^ //同时撤销add,保留工作区修改内容</span><br><span class="line">git reset --soft HEAD^ //不撤销add, 保留修改内容</span><br><span class="line">git reset --hard HEAD^ //同时撤销add,删除修改的内容</span><br><span class="line">git commit -amend // 修改commit信息</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>windows使用node多版本</title>
    <url>/2022/04/03/nvm/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开发过程中可能会出现，多个项目每个使用的node版本不一致情况，然而鱼与熊掌不可兼得，只能安装一个node版本。如果要多版本我们可以使用nvm工具<br><a id="more"></a></p>
<h2 id="1-安装nvm"><a href="#1-安装nvm" class="headerlink" title="1.安装nvm"></a>1.安装nvm</h2><p>下载地址：<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank">点我</a></p>
<h2 id="2-配置代理"><a href="#2-配置代理" class="headerlink" title="2. 配置代理"></a>2. 配置代理</h2><p>打开安装目录下的<code>setting.txt</code>加入以下到末尾<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node_mirror: http://npmmirror.com/mirrors/node/</span><br><span class="line">npm_mirror: http://npmmirror.com/mirrors/npm/</span><br></pre></td></tr></table></figure></p>
<h2 id="3-安装node"><a href="#3-安装node" class="headerlink" title="3.安装node"></a>3.安装node</h2><p>nvm常用命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm list available // 目前可用的node安装版本列表</span><br><span class="line">nvm list  // 列出目前所安装node版本列表</span><br><span class="line">nvm use 版本号  // 设置当前系统使用node的版本号,切换后可通过node -V查看是否切换成功</span><br><span class="line">nvm install 版本号  // 安装对应node版本到系统</span><br><span class="line">nvm uninstall 版本号 //  卸载对应node版本环境</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript数据属性和访问器属性</title>
    <url>/2019/06/19/javascript/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<code>javascript</code>中，我们访问对象的时候可以直接通过<code>obj.name</code>进行访问，删除时可以直接通过<code>delete obj.name</code>进行删除，那么你真的知道它为什么能直接访问或则删除么？如果你知道<code>javascript</code>中的数据属性，那就自然知道为什么能访问了；如果不知道呢，咱就接着往下看。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">   name:&quot;abc&quot;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.name)</span><br></pre></td></tr></table></figure></p>
<h2 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h2><p>在<code>javascript</code>中数据属性分为以下几种：</p>
<ul>
<li><code>configurable</code>:表示能否通过delete删除属性，从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为true。</li>
<li><code>enumerable</code>:表示能否通过<code>fon-in</code>循环返回属性，默认为true。</li>
<li><code>writable</code>:表示能否修改属性的值，默认为true。</li>
<li><code>value</code>:表示属性的数据值。默认为undefind。</li>
</ul>
<p>接下来我们尝试理解上面的含义，首先创建一个对象：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  name:&quot;张三&quot;,</span><br><span class="line">  age:12</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-configurable"><a href="#1-configurable" class="headerlink" title="1.configurable"></a>1.configurable</h3><p>根据configurable的定义，我们通过<code>Object.defineProperty</code>修改obj的name属性的数据属性<code>configurable</code>为false<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.defineProperty(obj,&quot;name&quot;,&#123;</span><br><span class="line"> configurable:false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据上面的定义，我们把configurable设为false时，我们不能通过delete进行删除属性,不能修改属性的特性，不能把属性修改为访问器属性。<br>删除属性：<br><img src="http://wx1.sinaimg.cn/large/005SNrnIgy1g281hehvbwj30cr064mx9.jpg" alt="image"><br>修改属性特性：<br><img src="http://wx4.sinaimg.cn/large/005SNrnIgy1g281m3gn70j30b70353yg.jpg" alt="image"><br>当我们把configurable属性修改为false的时候就不能再改回为true了，同时修改enumerable属性也会受到限制，当尝试修改时会报错。</p>
<h3 id="2-enumerable"><a href="#2-enumerable" class="headerlink" title="2.enumerable"></a>2.enumerable</h3><p>根据上面的定义，我们重新定义并修改name属性的enumerable为false，然后用for in遍历属性对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.defineProperty(obj,&quot;name&quot;,&#123;</span><br><span class="line">  enumerable:false</span><br><span class="line">&#125;)</span><br><span class="line">for(let key in obj)&#123;</span><br><span class="line">  console.log(key+&quot;--&quot;+obj[key])</span><br><span class="line">&#125;</span><br><span class="line">//输出</span><br><span class="line">age--12</span><br></pre></td></tr></table></figure></p>
<p>因为属性name的enumerable修改为了false,所以当我们用for in循环遍历obj对象时，我们无法遍历到name属性，所以上面代码只会打印age属性。</p>
<h3 id="3-writable和value"><a href="#3-writable和value" class="headerlink" title="3.writable和value"></a>3.writable和value</h3><p>value属性的值是否能被修改是根据writable确定的，当我们把writable的值设为true的时候，value可以被修改，否在反之。<br><img src="http://wx1.sinaimg.cn/large/005SNrnIgy1g2821jk29pj30by05jdfu.jpg" alt="image"><br>所以，当writable为false时，我们不能修改属性值，这里需要注意的是，如果configurable为false，此时我们可以将writable,但如果再设回为true就会报错。</p>
<h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p>访问器属性一共有四个，分别为<code>configurable</code>,<code>enumerable</code>,<code>get</code>,<code>set</code>，其中configurable和enumerable和数据属性中的是一样的，这里就不再进行说明</p>
<ul>
<li>get:在读取属性的时候会调用，默认值为undefind。</li>
<li>set:在设置属性的时候会调用，默认为undefind。</li>
</ul>
<p>同样的我们可以通过<code>Object.defineProperty</code>对访问器属性进行设定。有兴趣的小伙伴下来自己试试吧，今天没时间啦(<em>^_^</em>)。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>for循环应该这么用</title>
    <url>/2019/03/05/for/</url>
    <content><![CDATA[<p>从最开始学的for循环的遍历方法，再到后来连续不断出来的各种循环遍历方法，其实最大的区别就是应用的场景不同。而我们需要知道的是，什么情况下用哪一种方法合适</p>
<hr>
<a id="more"></a>
<p>下面我就以例子介绍每种方法再什么情况下用最合适：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [</span><br><span class="line"> &#123;id:&quot;1&quot;,money:10&#125;,</span><br><span class="line"> &#123;id:&quot;2&quot;,money:30&#125;,</span><br><span class="line"> &#123;id:&quot;3&quot;,money:40&#125;,</span><br><span class="line"> &#123;id:&quot;4&quot;,money:50&#125;,</span><br><span class="line"> &#123;id:&quot;5&quot;,money:60&#125;,</span><br><span class="line"> &#123;id:&quot;6&quot;,money:80&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<h2 id="1-给每一组数据的money都增大一点"><a href="#1-给每一组数据的money都增大一点" class="headerlink" title="1.给每一组数据的money都增大一点"></a>1.给每一组数据的<code>money</code>都增大一点</h2><p>这个时候可用到<code>forEach</code>方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.forEach(item =&gt; &#123; item.money += 10 &#125;));</span><br></pre></td></tr></table></figure></p>
<p><code>map</code>方法它说它也可以:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.map(item =&gt; &#123; item.money += 10 &#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>map</code>补充说，我还可以给你把money统计成一个新的数组给你；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let money = arr.map(item =&gt; &#123; return item.money += 10 &#125;);</span><br><span class="line">//[20,40,50,60,70,90]</span><br></pre></td></tr></table></figure></p>
<p>###<code>forEach</code>和<code>map</code>最大的区别就在于<code>forEach</code>没有返回值。</p>
<h2 id="2-只要这组数据中money大于50的数据（筛选）"><a href="#2-只要这组数据中money大于50的数据（筛选）" class="headerlink" title="2.只要这组数据中money大于50的数据（筛选）"></a>2.只要这组数据中money大于50的数据（筛选）</h2><p>从题目看就知道，筛选这种事一般都是<code>filter</code>来做的:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let filones = arr.filter(item =&gt; &#123; return item.money&gt;=50 &#125;);</span><br><span class="line">//[&#123;id:&quot;4&quot;,money:50&#125;,&#123;id:&quot;5&quot;,money:60&#125;,&#123;id:&quot;6&quot;,money:80&#125;]</span><br></pre></td></tr></table></figure></p>
<h2 id="3-这组数据中有money大于50的么-（有符合）"><a href="#3-这组数据中有money大于50的么-（有符合）" class="headerlink" title="3.这组数据中有money大于50的么 （有符合）"></a>3.这组数据中有money大于50的么 （有符合）</h2><p>这题意思就是，这组数据只要有money大于50的就符合，这个时候<code>some</code>就很有用了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let flag = arr.some(item =&gt; &#123; return item.money&gt;50 &#125;);</span><br><span class="line">//true</span><br></pre></td></tr></table></figure></p>
<p><code>some</code>它会去遍历查找满足条件的，当第一条就符合的时候，就会立即返回告诉你有符合的了，后面的就不用检查了。</p>
<h2 id="4-这组数据中money全是大于50的么？"><a href="#4-这组数据中money全是大于50的么？" class="headerlink" title="4.这组数据中money全是大于50的么？"></a>4.这组数据中money全是大于50的么？</h2><p>这个时候every就想知道这组数据中难道每条都大于50？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let flag = arr.every(item =&gt; &#123;return item.money&gt;50 &#125;)</span><br><span class="line">//false</span><br></pre></td></tr></table></figure></p>
<p>当每条数据都要去检查的时候，像这样会非常耗费性能;我们可以考虑反向检查，通过<code>some</code>检查是否有小于50的数据，再取反。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let flag = !arr.some(item =&gt; &#123;return item.money&lt;50 &#125;);</span><br><span class="line">//false</span><br></pre></td></tr></table></figure></p>
<h2 id="5-这组数据money总和是多少呢"><a href="#5-这组数据money总和是多少呢" class="headerlink" title="5.这组数据money总和是多少呢"></a>5.这组数据money总和是多少呢</h2><p>我们可以先通过用<code>map</code>将<code>money</code>取出来，再用<code>reduce</code>计算其总和。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let moneys = arr.map(item =&gt; &#123;return item.money &#125;);</span><br><span class="line">let sum = moneys.reduce((sum,moneys)=&gt;&#123; return moneys+sum&#125;,0)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是回流与重绘</title>
    <url>/2019/05/24/reflux/</url>
    <content><![CDATA[<p>要想知道什么是回流与重绘，首先我们得清楚浏览器的渲染过程。你知道是渲染过程是怎样的么？下面和我一起了解一下吧。<br><a id="more"></a></p>
<h1 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h1><ol>
<li>首先，解析<code>html</code>生成<code>DOM</code>树，解析<code>css</code>生成<code>CSSOM</code>树。</li>
<li>将<code>DOM</code>树和<code>CSSOM</code>树相结合生成渲染树(<code>Render Tree</code>)。</li>
<li>根据生成的渲染树，进行回流得到节点的位置、大小等信息。</li>
<li>根据渲染树以及回流得到的几何信息，得到节点的绝对像素。</li>
<li>将像素发给<code>GPU</code>，展示在页面上。</li>
</ol>
<p>渲染过程看起来虽然很简单，但是具体做了什么可能还不是太清楚吧，下面我们一一了解下。</p>
<h1 id="生成渲染树"><a href="#生成渲染树" class="headerlink" title="生成渲染树"></a>生成渲染树</h1><p>为了生成渲染树，浏览器主要做了以下工作：</p>
<ol>
<li>从<code>DOM</code>树的根节点开始遍历每个可见的节点。</li>
<li>对于每一个可见的节点，找到<code>CSSOM</code>树中的对应规则，并应用它们。</li>
<li>根据每一个可见的节点以及它们所对应的样式，组合生成渲染树。</li>
</ol>
<h4 id="注意：渲染树只包含可见节点。"><a href="#注意：渲染树只包含可见节点。" class="headerlink" title="注意：渲染树只包含可见节点。"></a>注意：渲染树只包含可见节点。</h4><p>不可见的节点包括：</p>
<ul>
<li>不会渲染输出的节点。如<code>script</code>、<code>meta</code>、<code>link</code>等标签。</li>
<li>通过css属性进行隐藏的节点，如<code>display:none</code>。（用<code>visibility</code>和<code>opacity</code>隐藏的节点还是会渲染到渲染树上。）</li>
</ul>
<h1 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h1><p>前面我们已经通过构造渲染树，将可见的节点以及它所对应的样式相结合起来，但是我们还需要计算每个节点在设备视图里所在的具体位置及大小。这个计算的过程我们就称为回流。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;title&gt;Critial Path: Hello world!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div style=&quot;width: 50%&quot;&gt;</span><br><span class="line">      &lt;div style=&quot;width: 50%&quot;&gt;Hello world!&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>以上代码中，我们可以看到第一个<code>div</code>将显示的尺寸设为了设备视窗的50%,第二个<code>div</code>设为了父节点宽度的50%，在回流的阶段我们就需要根据视窗的具体宽度，将其设为具体的像素值。</p>
<h1 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h1><p>我们通过构造渲染树和回流的阶段，知道了哪些节点是可见的，以及可见节点的样式和具体位置和大小信息，那么我们就可以将渲染树中的每一个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘。</p>
<h1 id="何时发生回流和重绘"><a href="#何时发生回流和重绘" class="headerlink" title="何时发生回流和重绘"></a>何时发生回流和重绘</h1><p>通过前面我们知道，回流主要是计算节点在设备上显示的具体位置及大小，那么当页面发生变化的时候就会触发回流。如：</p>
<ul>
<li>添加或删除可见的<code>DOM</code>元素。</li>
<li>元素的位置发生变化。</li>
<li>元素的尺寸发生变化（包括边框、边距、大小等）。</li>
<li>元素的文本内容发生变化。</li>
<li>浏览器的窗口大小发生改变（因为回流是根据视窗的大小来计算节点的具体位置的）。<h4 id="注意：回流一定会触发重绘，而重绘不一定会触发回流。"><a href="#注意：回流一定会触发重绘，而重绘不一定会触发回流。" class="headerlink" title="注意：回流一定会触发重绘，而重绘不一定会触发回流。"></a>注意：回流一定会触发重绘，而重绘不一定会触发回流。</h4></li>
</ul>
]]></content>
      <tags>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title>js编程题</title>
    <url>/2022/04/08/program/</url>
    <content><![CDATA[<p>日常js编程开发, 不定期编写<br><a id="more"></a></p>
<h2 id="链表相加"><a href="#链表相加" class="headerlink" title="链表相加"></a>链表相加</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListNode &#123;</span><br><span class="line">  constructor(val, next) &#123;</span><br><span class="line">    this.val = val ?? &quot;&quot;;</span><br><span class="line">    this.next = next ?? &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function generatorListNode(arr) &#123;</span><br><span class="line">  const head = new ListNode(arr[0]);</span><br><span class="line">  let cur = head;</span><br><span class="line">  for (let i = 1, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">    cur.next = new ListNode(arr[i]);</span><br><span class="line">    cur = cur.next;</span><br><span class="line">  &#125;</span><br><span class="line">  return head;</span><br><span class="line">&#125;</span><br><span class="line">const s1 = generatorListNode([1, 15, 3]),</span><br><span class="line">  s2 = generatorListNode([2, 15, 4]);</span><br><span class="line">function sum(s1, s2) &#123;</span><br><span class="line">  // head固定指针，tail移动指针</span><br><span class="line">  let head = null,</span><br><span class="line">    tail = null;</span><br><span class="line">  // 进位值</span><br><span class="line">  let county = 0;</span><br><span class="line">  while (s1 || s2) &#123;</span><br><span class="line">    const n1 = s1 ? s1.val : null;</span><br><span class="line">    const n2 = s2 ? s2.val : null;</span><br><span class="line">    const sum = n1 + n2 + county;</span><br><span class="line">    if (!head) &#123;</span><br><span class="line">      head = tail = new ListNode(sum % 10);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      tail.next = new ListNode(sum % 10);</span><br><span class="line">      tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    county = Math.floor(sum / 10);</span><br><span class="line">    if (s1) s1 = s1.next;</span><br><span class="line">    if (s2) s2 = s2.next;</span><br><span class="line">  &#125;</span><br><span class="line">  if (county &gt; 0) &#123;</span><br><span class="line">    tail.next = new ListNode(county);</span><br><span class="line">  &#125;</span><br><span class="line">  return head;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(s1, s2));</span><br></pre></td></tr></table></figure>
<h2 id="无重复字串最大长度"><a href="#无重复字串最大长度" class="headerlink" title="无重复字串最大长度"></a>无重复字串最大长度</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function noRepeatLen(str) &#123;</span><br><span class="line">  const list = new Set();</span><br><span class="line">  let left = -1,</span><br><span class="line">    ans = 0;</span><br><span class="line">  for (let i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">    if (i != 0) &#123;</span><br><span class="line">      list.delete(str.charAt(i - 1));</span><br><span class="line">    &#125;</span><br><span class="line">    while (!list.has(str.charAt(left + 1)) &amp;&amp; left + 1 &lt; str.length) &#123;</span><br><span class="line">      list.add(str.charAt(left + 1));</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = Math.max(ans, left - i + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br><span class="line">console.log(noRepeatLen(&quot;abcabcbb&quot;));</span><br></pre></td></tr></table></figure>
<h2 id="获取数组中任意两个元素相加等于提供的数的下标"><a href="#获取数组中任意两个元素相加等于提供的数的下标" class="headerlink" title="获取数组中任意两个元素相加等于提供的数的下标"></a>获取数组中任意两个元素相加等于提供的数的下标</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4,6],</span><br><span class="line">  sum = 9;</span><br><span class="line">const list = new Map();</span><br><span class="line">for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  const target = sum - arr[i];</span><br><span class="line">  if (!list.has(target)) &#123;</span><br><span class="line">    list.set(arr[i], i);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log([i, list.get(target)])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const str = &quot;sabcbas&quot;;</span><br><span class="line">function getResult(s) &#123;</span><br><span class="line">  if (!s || s.length === 1) return s;</span><br><span class="line">  const len = s.length;</span><br><span class="line">  let res = s[0];</span><br><span class="line">  for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    let j = 1;</span><br><span class="line">    let tempStr1 = &quot;&quot;,</span><br><span class="line">      tempStr2 = &quot;&quot;;</span><br><span class="line">    if (s[i] === s[i + 1] &amp;&amp; s[i + 1]) &#123;</span><br><span class="line">      const doubleStr = `$&#123;s[i]&#125;$&#123;s[i + 1]&#125;`;</span><br><span class="line">      res = res.length &gt; doubleStr.length ? res : doubleStr;</span><br><span class="line">    &#125;</span><br><span class="line">    tempStr1 = s[i];</span><br><span class="line">    while (s[i + j] === s[i - j] &amp;&amp; s[i + j] &amp;&amp; s[i - j]) &#123;</span><br><span class="line">      tempStr1 = s[i - j] + tempStr1 + s[i + j];</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    j = 1;</span><br><span class="line">    while (s[i - j] === s[i + j + 1] &amp;&amp; s[i - j] &amp;&amp; s[i + j - 1]) &#123;</span><br><span class="line">      tempStr2 = s[i - j] + tempStr2 + s[i + j - 1];</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    const temp = tempStr1.length &gt; tempStr2.length ? tempStr1 : tempStr2;</span><br><span class="line">    res = temp.length &gt; res.length ? temp : res;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line">console.log(getResult(str))</span><br></pre></td></tr></table></figure>
<h2 id="广度优先tree展平"><a href="#广度优先tree展平" class="headerlink" title="广度优先tree展平"></a>广度优先tree展平</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const tree = [&#123;&quot;id&quot;:1,&quot;pid&quot;:&quot;-1&quot;,&quot;children&quot;:[&#123;&quot;id&quot;:2,&quot;pid&quot;:&quot;1&quot;,&quot;children&quot;:[]&#125;,&#123;&quot;id&quot;:3,&quot;pid&quot;:&quot;1&quot;,&quot;children&quot;:[]&#125;]&#125;];</span><br><span class="line">function treeToList(tree) &#123;</span><br><span class="line">  let queen = [];</span><br><span class="line">  let result = [];</span><br><span class="line">  queen = queen.concat(tree);</span><br><span class="line">  while(queen.length) &#123;</span><br><span class="line">    let first = queen.shift();</span><br><span class="line">    if (first.children) &#123;</span><br><span class="line">      queen = queen.concat(first.children);  //深度优先使用unshift</span><br><span class="line">      delete first[&apos;children&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(first);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">console.log(treeToList(tree))</span><br></pre></td></tr></table></figure>
<h2 id="树节点路径查找"><a href="#树节点路径查找" class="headerlink" title="树节点路径查找"></a>树节点路径查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const tree = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: 1,</span><br><span class="line">    pid: &quot;-1&quot;,</span><br><span class="line">    name: &quot;1&quot;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: &quot;101&quot;,</span><br><span class="line">        pid: &quot;1&quot;,</span><br><span class="line">        name: &quot;1-1&quot;,</span><br><span class="line">        children: [&#123; id: &quot;1001&quot;, pid: &quot;1&quot;, name: &quot;1-1-1&quot; &#125;],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: &quot;102&quot;,</span><br><span class="line">        pid: &quot;1&quot;,</span><br><span class="line">        name: &quot;1-2&quot;,</span><br><span class="line">        children: [&#123; id: &quot;1002&quot;, pid: &quot;2&quot;, name: &quot;1-2-2&quot; &#125;],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: 2,</span><br><span class="line">    pid: &quot;-1&quot;,</span><br><span class="line">    name: &quot;2&quot;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: &quot;201&quot;,</span><br><span class="line">        pid: &quot;1&quot;,</span><br><span class="line">        name: &quot;2-1&quot;,</span><br><span class="line">        children: [&#123; id: &quot;2001&quot;, pid: &quot;1&quot;, name: &quot;2-1-1&quot; &#125;],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: &quot;202&quot;,</span><br><span class="line">        pid: &quot;1&quot;,</span><br><span class="line">        name: &quot;2-2&quot;,</span><br><span class="line">        children: [&#123; id: &quot;2002&quot;, pid: &quot;2&quot;, name: &quot;2-2-2&quot; &#125;],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line">function findTreePath(tree, func, path = []) &#123;</span><br><span class="line">  if(!tree.length) return [];</span><br><span class="line">  for (const data of tree) &#123;</span><br><span class="line">    path.push(data.id);</span><br><span class="line">    if (func(data)) return path;</span><br><span class="line">    if (data.children) &#123;</span><br><span class="line">      const findChildren = findTreePath(data.children, func, path);</span><br><span class="line">      if (findChildren.length) return findChildren;</span><br><span class="line">    &#125;</span><br><span class="line">    path.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  retur [];</span><br><span class="line">&#125;</span><br><span class="line">findTreePath(tree, node=&gt;node.id===&apos;&apos;);</span><br><span class="line">//========多路径查找</span><br><span class="line">function findTreePath(tree, func, path = [], result = []) &#123;</span><br><span class="line">  if(!tree.path) return [];</span><br><span class="line">  for(const data of tree) &#123;</span><br><span class="line">    path.push(data.id);</span><br><span class="line">    if(func(data)) result.push([...path]);</span><br><span class="line">    if (data.children) findTreePath(data.children, func, path, result);</span><br><span class="line">    path.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">findTreePath(tree, node=&gt;node.id===&apos;&apos; || node.name===&apos;test&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="列表转树"><a href="#列表转树" class="headerlink" title="列表转树"></a>列表转树</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function listTotree(tree) &#123;</span><br><span class="line">  const mapArr = tree.reduce((map, node) =&gt; (map[node.id] = node, node.children = [], map), &#123;&#125;);</span><br><span class="line">  const result = tree.filter(item=&gt;&#123;</span><br><span class="line">    if(item.pid) mapArr[item.pid].children.push(item);</span><br><span class="line">    return !item.pid</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 一次循环</span><br><span class="line">function listTotree(tree) &#123;</span><br><span class="line">  const map = &#123;&#125;;</span><br><span class="line">  const result = [];</span><br><span class="line">  for(const data of tree) &#123;</span><br><span class="line">    map[data.id] = data;</span><br><span class="line">    map[data.id].children = [];</span><br><span class="line">    const parentRoot = map[data.pid];</span><br><span class="line">    if (!parentRoot) &#123;</span><br><span class="line">      result.push(data)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      !parentRoot.children &amp;&amp; (parentRoot.children = []);</span><br><span class="line">      parentRoot.children.push(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fisheYete(arr) &#123;</span><br><span class="line">  const list = arr.slice(0);</span><br><span class="line">  for(let i=list.length - 1;i&gt;0;i--) &#123;</span><br><span class="line">    const randIdx = Math.floor(Math.random()*(i+1));</span><br><span class="line">    [list[i], list[randIdx]] = [list[randIdx], list[i]]</span><br><span class="line">  &#125;</span><br><span class="line">  return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>vue路由归纳</title>
    <url>/2019/04/05/vue-router/</url>
    <content><![CDATA[<h2 id="vue路由的原理"><a href="#vue路由的原理" class="headerlink" title="vue路由的原理"></a>vue路由的原理</h2><p>单页面的一大优势就是，无刷新跳转页面，用户体验好，加载速度快。vue路由的跳转它是无刷新的，共有两种模式，可以通过路由配置文件中去配置<code>mode</code>字段，如果不去配置这个<code>mode</code>字段，默认路由跳转就为<code>hash</code>模式。</p>
<p><code>hash</code>模式，通过在链接后面添加”#”号+路由名字，匹配这个字段的变化去触发<code>hashchange</code>事件，动态的渲染出页面。</p>
<p>另外一种模式为<code>history</code>模式，即使用浏览器的historyAPI,<code>pushState</code>和<code>replaceState</code>。通过调用<code>pushState</code>去操作浏览器的<code>history</code>对象，改变当前链接地址，同时结合<code>window.onpopstate</code>监控浏览器的返回前进事件，同样可以实现无刷新的跳转页面。<code>replaceState</code>和<code>pushState</code>的区别就是，前者代表替换，后者代表插入。</p>
<a id="more"></a>
<p><code>history</code>相对于<code>hash</code>，就是没有”#”号，看着十分清爽。但是用hash模式的反而较多，为什么呢？因为<code>history</code>模式还需要后端的配置，否则刷新页面就会返回404。</p>
<h2 id="vue路由两种传参"><a href="#vue路由两种传参" class="headerlink" title="vue路由两种传参"></a>vue路由两种传参</h2><p>页面传参就两种，<code>params</code>和<code>query</code>,<code>params</code>是以<code>/params</code>方式展示，<code>query</code>是以<code>/?query=</code>方式展示。写法大致都是相同，不过<code>query</code>是用<code>path</code>来引入，而<code>params</code>是用<code>name</code>来引入。注意：接收参数的时候是用<code>route</code>而不是<code>router</code>。<code>query</code>像是ajax中的get,而<code>params</code>更像是post,刷新页面时<code>params</code>参数会丢失,而<code>query</code>参数不会丢失。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//query</span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">  path:&quot;/abc&quot;,</span><br><span class="line">  query:&#123;id:id&#125;</span><br><span class="line">&#125;);</span><br><span class="line">//params</span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">   name:&quot;abc&quot;</span><br><span class="line">   params:&#123;id:id&#125;</span><br><span class="line">&#125;);</span><br><span class="line">//接收参数</span><br><span class="line">this.$route.query.name</span><br><span class="line">this.$route.params.name</span><br></pre></td></tr></table></figure></p>
<h2 id="vue路由跳转"><a href="#vue路由跳转" class="headerlink" title="vue路由跳转"></a>vue路由跳转</h2><p>vue 路由的跳转分成两种，一种是声明式，使用<code>&lt;router-link&gt;</code>声明跳转，<code>to</code>属性定义跳转的参数。另一种是编程式，使用 <code>router.go()</code>、<code>router.push()</code>、<code>router.replace()</code>方法进行跳转，<code>go</code>方法就是与浏览器的history api 的方法相同，可以进行返回上一页等操作。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">router.push(&apos;home&apos;)</span><br><span class="line"></span><br><span class="line">// 对象</span><br><span class="line">this.$router.push(&#123;path: &apos;home&apos;&#125;)</span><br><span class="line"></span><br><span class="line">//命名的路由</span><br><span class="line">this.$router.push(&#123;name: &apos;user&apos;, params: &#123;userId: 123&#125;&#125;)</span><br><span class="line"></span><br><span class="line">// 带查询参数，变成/register?plan=private</span><br><span class="line">this.$router.push(&#123;path: &apos;register&apos;, query: &#123;plan: &quot;private&quot;&#125;&#125;);</span><br><span class="line"></span><br><span class="line">//声明式</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:&apos;abc&apos;,params:&#123;id:id&#125;&#125;&quot;&gt;&lt;/route-link&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="vue路由守卫"><a href="#vue路由守卫" class="headerlink" title="vue路由守卫"></a>vue路由守卫</h2><p>vue路由守卫分3种，一种是全局路由守卫，通常在实例化路由之后设置，做通用路由的设置，它所有的路由跳转全部都会执行的操作；一种是单独的路由独享守卫，在单个路由定义的时候设置，所有跳转到这个路由的都会执行，一种是组件内的路由守卫，只在组件内生效。</p>
<p> 全局路由守卫：</p>
<ul>
<li><code>router.beforeEach(to,from,next)</code></li>
<li><code>router.afterEach(to,from,next)</code></li>
</ul>
<p>路由独享守卫：</p>
<ul>
<li><code>beforeEnter(to,from,next)</code></li>
</ul>
<p>组件内守卫：</p>
<ul>
<li><code>beforeRouteEnter(to,from,next)</code></li>
<li><code>beforeRouteUpdate(to,from,next)</code>  //动态参数路径改变时，组件实例被复用的时候调用</li>
<li><code>beforeRouteLeave(to,from,next)</code>   //导航离开组件所在路由时被调用</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vueCli+vant+tsx使用问题</title>
    <url>/2022/03/31/vue-vant-ts/</url>
    <content><![CDATA[<p>在vueCli+ts中按需引用vant没有样式？生产环境打包无vant样式？build失败？那是因为你没有配置这些<br><a id="more"></a></p>
<h2 id="一、按需引用vant无样式"><a href="#一、按需引用vant无样式" class="headerlink" title="一、按需引用vant无样式"></a>一、按需引用vant无样式</h2><p>如果你通过以下配置后依然无样式，可在<code>vue.config.js</code>中配置css下面的<code>requireModuleExtension: true</code>属性,再重启服务查看<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">babel.config.js</span><br><span class="line">plugins: [</span><br><span class="line">  &quot;import&quot;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;libraryName&quot;: &quot;vant&quot;,</span><br><span class="line">      &quot;style&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">  &quot;vant&quot;</span><br><span class="line">]</span><br><span class="line">vue.config.js</span><br><span class="line">&#123;</span><br><span class="line">  loader: &quot;ts-loader&quot;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    getCustomTransformers: () =&gt; (&#123;</span><br><span class="line">      before: [</span><br><span class="line">        require(&quot;ts-import-plugin&quot;)(&#123;</span><br><span class="line">          libraryName: &quot;vant&quot;,</span><br><span class="line">          libraryDirectory: &quot;es&quot;,</span><br><span class="line">          style: true</span><br><span class="line">        &#125;)</span><br><span class="line">      ]</span><br><span class="line">    &#125;),</span><br><span class="line">    compilerOptions: &#123;</span><br><span class="line">      module: &quot;es2015&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二、生产环境打包无按需引入vant样式"><a href="#二、生产环境打包无按需引入vant样式" class="headerlink" title="二、生产环境打包无按需引入vant样式"></a>二、生产环境打包无按需引入vant样式</h2><p>配置<code>vue.config.js</code>中的<code>parallel: false</code>属性,该属性为是否使用thread-loader来解析babel或typescript,当配置为true时, 会将你的<code>loader</code>放在一个<code>work池</code>中，<code>work池</code>中的<code>loader</code>会受到一些限制，如：</p>
<ul>
<li>这些<code>loader</code>不能产生新文件</li>
<li>无法获取<code>webpack</code>的选项配置<h2 id="三、配置了ts-loader后，项目打包失败"><a href="#三、配置了ts-loader后，项目打包失败" class="headerlink" title="三、配置了ts-loader后，项目打包失败"></a>三、配置了ts-loader后，项目打包失败</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  loader: &quot;ts-loader&quot;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    happyPackMode: true, // 配置此属性</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="四、如何使用vue-config-ts"><a href="#四、如何使用vue-config-ts" class="headerlink" title="四、如何使用vue.config.ts"></a>四、如何使用vue.config.ts</h2><p>通过查阅vue-cli-service源码后，发现启动时会有一个获取全局变量<code>VUE_CLI_SERVICE_CONFIG_PATH</code>,来确定使用的文件，如无配置将使用<code>vue.config.js</code>,因此可使用如下配置</p>
<ol>
<li>安装<code>cross-env ts-node</code></li>
<li>配置<code>tsconfig.json</code></li>
<li>修改<code>script命令</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsconfig.json // 让ts-node支持编译js</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ts-node&quot;: &#123;</span><br><span class="line">    &quot;transpileOnly&quot;: true,</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">      &quot;module&quot;: &quot;commonjs&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;service&quot;: &quot;cross-env VUE_CLI_SERVICE_CONFIG_PATH=./vue.config.ts ts-node ./node_modules/@vue/cli-service/bin/vue-cli-service.js&quot;,</span><br><span class="line">    &quot;serve&quot;: &quot;npm run service serve&quot; // 等同于vue-cli-service serve 如需携带参数可通过 -- --mode dev</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="五、node低版本运行服务，ts-node启动失败"><a href="#五、node低版本运行服务，ts-node启动失败" class="headerlink" title="五、node低版本运行服务，ts-node启动失败"></a>五、node低版本运行服务，ts-node启动失败</h2><p>报错 <code>catch { Unknown Error token</code>, 原因是因为低版本node无法支持识别 <code>catch{}</code>不带括号,解决方案</p>
<ol>
<li>升级<code>node</code>版本</li>
<li>无法升级node时，可通过打补丁<ul>
<li>安装<code>patch-package</code>,使用<code>yarn</code>命令时还需安装<code>postinstall-postinstall</code>,<code>npm</code>无需安装</li>
<li>修改<code>node_modules</code>中包的源码</li>
<li><code>package.json</code>中增加一条命令<code>&quot;postinstall&quot;: &quot;patch-package&quot;</code></li>
<li>运行<code>npm run patch-package ts-node</code>生成补丁包，后续重新安装包就都不会影响到。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>关于vuex</title>
    <url>/2019/05/05/vue-interview/</url>
    <content><![CDATA[<h2 id="vuex数据流"><a href="#vuex数据流" class="headerlink" title="vuex数据流"></a>vuex数据流</h2><p>说实话，看了官方文档我并不清楚vuex到底是个什么东西，通过例子，我知道如何使用后，我才慢慢理解一点。我的理解就是：为什么会存在组件不能通信？简单粗暴的回答就是，变量的作用域导致的，vue的每一个组件都有自己的生命周期，都是独立存在的个体。vuex就是在根组件创建一个叫state的全局变量，让不同组件共享这个变量，并且定义了一系列方法和规范，也就是action、mutation等等，去统一触发这个全局变量也就是state。<br><a id="more"></a></p>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// store/index.js</span><br><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line">import Vuex from <span class="string">'vuex'</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  <span class="function"><span class="title">state</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      monitorInfo: &#123;</span><br><span class="line">        name: <span class="string">''</span>,</span><br><span class="line">        description: <span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    updateMonitorInfo: (&#123;commit&#125;, info) =&gt; &#123;</span><br><span class="line">      commit(<span class="string">'UPDATE_MONITOR_INFO'</span>, info)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    UPDATE_MONITOR_INFO: (state, info) =&gt; &#123;</span><br><span class="line">      window.localStorage.setItem(<span class="string">'monitorInfo'</span>, JSON.stringify(info))</span><br><span class="line">      state.monitorInfo = info</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    monitorInfo: (state) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!state.monitorInfo.name) &#123;</span><br><span class="line">        state.monitorInfo = JSON.parse(window.localStorage.getItem(<span class="string">'monitorInfo'</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> state.monitorInfo</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">export</span> default store</span><br></pre></td></tr></table></figure>
<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- list 兄弟组件的发送方--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; mapActions &#125; from &apos;vuex&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      ...mapActions([&apos;updateMonitorInfo&apos;]),</span><br><span class="line">      goNextPage (row, routerName) &#123;</span><br><span class="line">        let monitorInfo = &#123;</span><br><span class="line">          name: row.name,</span><br><span class="line">          serviceUrl: row.serviceUrl,</span><br><span class="line">          description: row.info.description</span><br><span class="line">        &#125;</span><br><span class="line">        this.updateMonitorInfo(monitorInfo)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- monitor.vue  兄弟组件接收方--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;span&gt;&#123;monitorInfo.name&#125;&lt;/span&gt;</span><br><span class="line">  &lt;span&gt;&#123;monitorInfo.description&#125;&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; mapGetters &#125; from &apos;vuex&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      ...mapGetters([&apos;monitorInfo&apos;])</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;   </span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖与节流</title>
    <url>/2019/04/28/vue-shake/</url>
    <content><![CDATA[<h2 id="什么是节流与防抖呢"><a href="#什么是节流与防抖呢" class="headerlink" title="什么是节流与防抖呢"></a>什么是节流与防抖呢</h2><p>在开发环境中，我们经常会遇见这样的问题，一个按钮连续点击就会连续调用<code>api</code>，从而使之出现不必要的麻烦。那么我们要怎么解决这样的问题呢？解决方法有很多，但是这里我想说的是利用函数防抖与节流来解决这样的问题，至于为什么我要使用防抖与节流来解决这样的问题看了下面你们就知道啦。</p>
<ul>
<li>函数防抖： 一个任务频繁触发的情况下，只有任务触发的间隔时间超过指定间隔的时候，任务才会去执行。</li>
<li>函数节流：在指定的时间间隔里只会去执行一次任务。<a id="more"></a>
<h2 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流(throttle)"></a>函数节流(throttle)</h2>在这里我以判断页面滚动到底部为例，平常普通的做法就是通过监听 <code>window</code> 的 <code>scroll</code> 事件，然后在函数体内写入判断是否滚动到底部的逻辑：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(window).on(&quot;scroll&quot;,function()&#123;</span><br><span class="line">  //判断是否滚动到底部逻辑,只要浏览器滚动就会进入此函数体</span><br><span class="line">  let pageHeight = $(&quot;body&quot;).height(), //页面高度</span><br><span class="line">      scrollTop = $(window).scrollTop(), //滚动条距离顶部的距离</span><br><span class="line">      winHeight = $(window).height(),  //浏览器窗口的高度</span><br><span class="line">      thred = pageHeight - scrollTop - winHeight;</span><br><span class="line">      if(thred &gt; -100 &amp;&amp; thred &lt;=20)&#123;</span><br><span class="line">        console.log(end)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样做的话有一个缺点就是耗性能，因为在滚动的时候，浏览器无时无刻都在计算着滚动条是否滚动到底部的逻辑，然而在实际场景中我们并不需要这样做，实际上工作中我们可能是这样：在滚动的过程中，隔一段时间再去计算滚动到底部的逻辑。而函数节流所做的工作就是每隔一段时间就去执行一次原本无时无刻执行的函数。所以在滚动中用它是不错的选择：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Throttling(fn,time = 1000)&#123;</span><br><span class="line">  let timer = null;  // 保存此标记判读是否执行函数</span><br><span class="line">  return function()&#123;</span><br><span class="line">    if(!timer) &#123;</span><br><span class="line">        timer = setTimeout(()=&gt;&#123;</span><br><span class="line">          fn.apply(this,arguments);</span><br><span class="line">         timer = null;// 这里设置为null，是为了实现滚动经过400ms过后再次执行函数</span><br><span class="line">        &#125;,time)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用方法</span><br><span class="line">$(windwo).on(&quot;scroll&quot;,Throttling(</span><br><span class="line"> function()&#123;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line">),400)</span><br></pre></td></tr></table></figure></p>
<h2 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h2><p>在这里我以注册用户为例,大多数网站的验证用户是否被注册都是通过 <code>input</code> 框中输入的时候去验证是否被注册，而不是在 <code>input</code> 失去焦点的时候去验证，大概是为了提高用户体验而这样做的吧。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.username&quot;).on(&quot;input&quot;,function()&#123;</span><br><span class="line"> $.ajax(&#123;</span><br><span class="line">   ...</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>显而易见这样的做法是不好的，当用户在 <code>input</code> 框中输入每一个字符时都会去调用后台接口验证用户是否被注册，这样不仅对服务器的压力增加，同时体验反而也没有原本的失去焦点效果好。理想的做法就是，当用户输入第一个字符过后的一段时间内如果还有字符输入的话，就暂时不去请求后台<code>api</code>验证用户是否被注册,函数防抖就是为了解决这样的问题。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(fn,time = 1000)&#123;</span><br><span class="line">  let timer;</span><br><span class="line">  return function()&#123;</span><br><span class="line">     clearTimeout(timer); // 当键盘连续输入时候,不执行函数</span><br><span class="line">     timer = setTimeout(()=&gt;&#123;</span><br><span class="line">       fn.apply(this,arguments);//传入this,是为了让fn函数中的this指向.apply中的第一个参数</span><br><span class="line">     &#125;,time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用方法</span><br><span class="line">$(&quot;.username&quot;).on(&quot;input&quot;,debounce(function()&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>typescript分享</title>
    <url>/2022/05/11/typescript/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>typescript</code>是<code>javascript</code>的超集, 具有可选的类型，并且可以编译为纯<code>javascript</code>运行。可以看作<code>typescript</code>是<code>javascript</code>的<code>Lint</code>，能为<code>javascript</code>增加规范。<br><a id="more"></a><br>为什么要使用<code>typescript</code>?</p>
<ul>
<li><code>js</code>为动态类型语言，实例化之前我们都不知道变量具体的类型是什么，使用<code>ts</code>可以避免如:<code>Uncaught TypeError：&#39;xxx&#39; is not a function</code></li>
<li>规范方便，不易出错，提示友好,增强了编辑器功能如：<code>提示</code>、<code>代码补全</code>、<code>接口提示</code>、<code>跳转到定义</code>等</li>
<li>对函数参数类型限制，对数组对象类型限制，避免定义出错，如数据解构复杂较多时。</li>
<li>可读性和维护性，如: 看后端接口返回值需到network或接口文档看, 而使用<code>ts</code>，在编辑器中就会直接提醒</li>
<li>编译阶段发现大部分错误<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2></li>
<li>有学习成本，需理解接口<code>interface</code>、泛型、类、枚举类型等</li>
<li>会增加一些<code>开发成本</code>, 不过只是前期</li>
<li>编译<code>typescript</code>需要时间，意味着项目大了过后开发和生产环境编译速度成了考验<h2 id="ts类型"><a href="#ts类型" class="headerlink" title="ts类型"></a>ts类型</h2></li>
<li>常用: boolean、string、number、array、enum、any、void</li>
<li>不常用: tuple、null、undefined、never<br>元组：已知元素数量和类型的数组、各元素类型可以不相同、但是位置上的类型必须相同<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const test: [string, number] = [&quot;1&quot;, 2]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>undefined,null：属于所有基本类型的子类，所以可以赋值给其他已定义的类型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const test: string = undefined</span><br></pre></td></tr></table></figure></p>
<p>object: 是<code>javascript</code>的常规对象类型,并不是基础数据类型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const test = (val: object) =&gt; &#123;&#125;</span><br><span class="line">test(null), test(undefined) // error</span><br></pre></td></tr></table></figure></p>
<p>对象类型，首先理解下<code>interface</code>和<code>type</code>的区别：<code>type</code>(类型别名)更强,右侧可以是任意类型, 凡是可以用interface来定义的type也可以，type可以声明元组、联合类型、基本类型别名,<code>interface</code>(接口)可以进行声明合并<code>type</code>不行。使用中一般<code>interface</code>偏多,需要用到其他类型时会使用<code>type</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Test &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line">interface TestChild extends Test &#123;</span><br><span class="line">  sex: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unknown,any<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// unknown可以表示任意类型，同时也告诉TS开发者也不知道具体类型</span><br><span class="line">const test: unknown</span><br><span class="line">test.toFixed(1) // error</span><br><span class="line">if (typeof test === &apos;number&apos;) &#123;</span><br><span class="line">  test.toFixed(1) // ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>联合类型: 由两个或多个其他类型组成，表示可能为其中任何一个值，类型间使用’|’隔开，较多时可使用type声明<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Test = string | number</span><br><span class="line">// 联合类型的隐式推到可能会导致错误, 访问不共同具有的属性</span><br><span class="line">function test(value: Test): number &#123;</span><br><span class="line">  return value.length; // number类型不具备length会报错，可通过tyepof value === &apos;string&apos;判断下</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>never: 是其他类型包括(null和undefined)的子类型，代表从不会出现的值<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用情况: 当有个联合类型type</span><br><span class="line">interface One &#123;</span><br><span class="line">  type: &apos;One&apos;</span><br><span class="line">&#125;</span><br><span class="line">interface Two &#123;</span><br><span class="line">  type: &apos;Two&apos;</span><br><span class="line">&#125;</span><br><span class="line">type Test = One | Two;</span><br><span class="line">function Test(type: Test) &#123;</span><br><span class="line">  // switch中,ts是可以收窄类型</span><br><span class="line">  switch(type) &#123;</span><br><span class="line">    &apos;One&apos;: break // type为One类型</span><br><span class="line">    &apos;Two&apos;: break // type为Two类型</span><br><span class="line">    default:</span><br><span class="line">      let val: never = type</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">当type新增一个类型Three时，Test中switch忘记针对新类型处理时，进入default此时type收窄为Three类型，无法赋值给never导致编译错误</span><br><span class="line">第二种: 当函数返回值是抛出异常的时候</span><br><span class="line">function Test(msg: string): never &#123;</span><br><span class="line">  throw new Error(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>void: 表示对函数的返回值并不在意或者该函数无返回值<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Props &#123;</span><br><span class="line">  fun: () =&gt; void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>enum: 枚举,底层为number的实现<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">普通枚举</span><br><span class="line">enum Test &#123;</span><br><span class="line">  a,</span><br><span class="line">  b,</span><br><span class="line">  c</span><br><span class="line">&#125;</span><br><span class="line">const test: Test = Test.a // 0</span><br><span class="line">字符串枚举</span><br><span class="line">enum Test &#123;</span><br><span class="line">  a = &apos;a&apos;,</span><br><span class="line">  b = &apos;b&apos;</span><br><span class="line">&#125;</span><br><span class="line">混合枚举</span><br><span class="line">enum Test &#123;</span><br><span class="line">  a = &apos;a&apos;,</span><br><span class="line">  b = 2</span><br><span class="line">&#125;</span><br><span class="line">//=====</span><br><span class="line">enum Test &#123;</span><br><span class="line">  a,</span><br><span class="line">  b,</span><br><span class="line">  c = 4,</span><br><span class="line">  d</span><br><span class="line">&#125;</span><br><span class="line">//=======</span><br><span class="line">const getValue = () =&gt; return 4;</span><br><span class="line">enum Test &#123;</span><br><span class="line">  a = getValue(),</span><br><span class="line">  b,</span><br><span class="line">  c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>泛型: 通过传入的参数类型来得到具体的类型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基础样式</span><br><span class="line">function Test&lt;T&gt;(value: T): T &#123;</span><br><span class="line">  return value</span><br><span class="line">&#125;</span><br><span class="line">Test&lt;string&gt;(&apos;a&apos;) // 代表返回类型为string，参数也为string类型</span><br><span class="line"></span><br><span class="line">当把泛型理解为一种方法实现时，会想到方法有多个参数、默认值；泛型也可以</span><br><span class="line">type Test&lt;T, U = string&gt; = &#123;</span><br><span class="line">  a: T,</span><br><span class="line">  b: U</span><br><span class="line">&#125;</span><br><span class="line">type A = Test&lt;number&gt; // A = &#123; a: number, b: string &#125;</span><br><span class="line">type B = Test&lt;number, number&gt; // B = &#123; a: number, b: number &#125;</span><br><span class="line">//==========</span><br><span class="line">是函数的话，就会有一些限制约束</span><br><span class="line">1. Readonly: 构造一个所有属性为只读，无法重新分配所构造的类型的属性</span><br><span class="line">interface Test &#123;</span><br><span class="line">  a: string</span><br><span class="line">&#125;</span><br><span class="line">const test: Readonly&lt;Test&gt; = &#123;</span><br><span class="line">  a: &apos;a&apos;</span><br><span class="line">&#125;</span><br><span class="line">test.a = &apos;b&apos; // Cannot assign to &apos;title&apos; because it is a read-only property</span><br><span class="line">2. Pick&lt;T, K&gt;: 从T中挑选出一些K属性来构造一个类型</span><br><span class="line">interface Test &#123;</span><br><span class="line">  a: string;</span><br><span class="line">  b: string;</span><br><span class="line">  c: string;</span><br><span class="line">&#125;</span><br><span class="line">type TestPick = Pick&lt;Test, &apos;a&apos; | &apos;b&apos;&gt;</span><br><span class="line">const test: TestPick = &#123;</span><br><span class="line">  a: &apos;a&apos;,</span><br><span class="line">  b: &apos;b&apos;</span><br><span class="line">&#125;</span><br><span class="line">3. Omit&lt;T, K&gt;: 从T中排除一些K属性来构造一个类型</span><br><span class="line">type TestOmit = Omit&lt;Test, &apos;a&apos;&gt;</span><br><span class="line">const test: TestOmit = &#123;</span><br><span class="line">  b: &apos;b&apos;,</span><br><span class="line">  c: &apos;c&apos;</span><br><span class="line">&#125;</span><br><span class="line">4. Record: 约束键类型为keys, 值类型为values的对象类型</span><br><span class="line">enum Test &#123;</span><br><span class="line">  a = &apos;name&apos;,</span><br><span class="line">  b = &apos;age&apos;</span><br><span class="line">&#125;</span><br><span class="line">const test: Record&lt;Test, string&gt; = &#123;</span><br><span class="line">  [Test.a]: &apos;a&apos;</span><br><span class="line">&#125;</span><br><span class="line">// error: 类型中缺少属性&apos;age&apos;, 但类型Record中需要该属性，因此也可以做全面性检查</span><br><span class="line">keyof 关键字可以用来获取一个对象的所有key</span><br><span class="line">type Test = &#123;</span><br><span class="line">  id: string;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line">type TestKeys = keyof Test // &apos;id&apos; | &apos;name&apos;</span><br><span class="line">5. Extract&lt;T, U&gt;: 从T和U中提取相同的类型</span><br><span class="line">interface Test &#123;</span><br><span class="line">  a: string;</span><br><span class="line">  b: string;</span><br><span class="line">&#125;</span><br><span class="line">interface Uest &#123;</span><br><span class="line">  b: string;</span><br><span class="line">  c: string;</span><br><span class="line">&#125;</span><br><span class="line">type TestExtra = Extract&lt;Test, Uest&gt;;</span><br><span class="line">const test: TestExtra = &#123;</span><br><span class="line">  b: &apos;b&apos;</span><br><span class="line">&#125;</span><br><span class="line">6.Partial: 所有属性可选</span><br><span class="line">interface Test &#123;</span><br><span class="line">  a: string;</span><br><span class="line">  b: string;</span><br><span class="line">&#125;</span><br><span class="line">type PartialTest = Partial&lt;Test&gt; // &#123; a?: string; b?: string &#125;</span><br><span class="line">7. Required: 所有属性必选</span><br><span class="line">type Test = &#123;</span><br><span class="line">  a?: string;</span><br><span class="line">  b: string;</span><br><span class="line">&#125;</span><br><span class="line">type RequiredTest = Required&lt;Test&gt; // &#123; a: string; b: string &#125;</span><br></pre></td></tr></table></figure></p>
<p>索引签名: 可以来定义任意key为string,value为number的类型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Test &#123;</span><br><span class="line">  [key: string]: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TS的断言: 类型断言不是类型转换,断言成一个联合类型中不存在的类型是不允许的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">断言写法</span><br><span class="line">1. &lt;类型&gt;值: &lt;string&gt;test</span><br><span class="line">2. value as string</span><br><span class="line">3. 非空断言: 用于从类型中删除null, undefined不进行检查. 在表达式之后写入代表该值不是null和undefined // test!.toFixed()</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
